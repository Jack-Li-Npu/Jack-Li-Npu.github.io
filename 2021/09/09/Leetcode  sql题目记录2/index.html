
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>Leetcode sql题目记录2 | KING!BOB!</title>
    <meta name="author" content="KING BOB" />
    <meta name="description" content="LET'S MAKE IT HAPPEN" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/pic.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>KING!BOB!</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;KING!BOB!</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>Leetcode sql题目记录2</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2021/9/9
        </span>
        
        <span class="category">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                数据库
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/Leetcode/" style="color: #ffa2c4">
                    Leetcode
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="Leetcode-sql题目记录2"><a href="#Leetcode-sql题目记录2" class="headerlink" title="Leetcode  sql题目记录2"></a>Leetcode  sql题目记录2</h2><p>本博客仅记录**高频 SQL 50 题（进阶版）**中的中等难度题目，后续不定期更新</p>
<h3 id="1398-购买了产品A和产品B却没有购买产品C的顾客"><a href="#1398-购买了产品A和产品B却没有购买产品C的顾客" class="headerlink" title="1398.购买了产品A和产品B却没有购买产品C的顾客"></a>1398.购买了产品A和产品B却没有购买产品C的顾客</h3><p> <code>Customers</code> 表：</p>
<pre><code>+---------------------+---------+
| Column Name         | Type    |
+---------------------+---------+
| customer_id         | int     |
| customer_name       | varchar |
+---------------------+---------+
customer_id 是这张表中具有唯一值的列。
customer_name 是顾客的名称。
</code></pre>
<p><code>Orders</code> 表：</p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| customer_id   | int     |
| product_name  | varchar |
+---------------+---------+
order_id 是这张表中具有唯一值的列。
customer_id 是购买了名为 &quot;product_name&quot; 产品顾客的id。
</code></pre>
<p>请你编写解决方案，报告购买了产品 <strong>“A”</strong>，<strong>“B”</strong> 但没有购买产品 <strong>“C”</strong> 的客户的 customer_id 和 customer_name，因为我们想推荐他们购买这样的产品。</p>
<p>返回按 <code>customer_id</code> <strong>排序</strong> 的结果表。</p>
<p>返回结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Customers table:
+-------------+---------------+
| customer_id | customer_name |
+-------------+---------------+
| 1           | Daniel        |
| 2           | Diana         |
| 3           | Elizabeth     |
| 4           | Jhon          |
+-------------+---------------+

Orders table:
+------------+--------------+---------------+
| order_id   | customer_id  | product_name  |
+------------+--------------+---------------+
| 10         |     1        |     A         |
| 20         |     1        |     B         |
| 30         |     1        |     D         |
| 40         |     1        |     C         |
| 50         |     2        |     A         |
| 60         |     3        |     A         |
| 70         |     3        |     B         |
| 80         |     3        |     D         |
| 90         |     4        |     C         |
+------------+--------------+---------------+
输出：
+-------------+---------------+
| customer_id | customer_name |
+-------------+---------------+
| 3           | Elizabeth     |
+-------------+---------------+
解释：
只有 customer_id 为 3 的顾客购买了产品 A 和产品 B ，却没有购买产品 C 。
</code></pre>
<p><strong>解答：</strong></p>
<p><strong>（1）最基础解法，逐一子查询</strong></p>
<pre><code class="language-sql">SELECT c.customer_id, c.customer_name
FROM Customers c
WHERE EXISTS (
    SELECT 1 FROM Orders o WHERE o.customer_id = c.customer_id AND o.product_name = &#39;A&#39;
)
AND EXISTS (
    SELECT 1 FROM Orders o WHERE o.customer_id = c.customer_id AND o.product_name = &#39;B&#39;
)
AND NOT EXISTS (
    SELECT 1 FROM Orders o WHERE o.customer_id = c.customer_id AND o.product_name = &#39;C&#39;
);
</code></pre>
<p>注意：在判断某列不在某个子查询的结果列表里时，如果子查询里有null值，则not in会返回空。因此需要用not exists。</p>
<p>当 <code>NOT IN</code> 拆成多个比较后，如果其中有一个条件返回 <code>UNKNOWN</code>，整个 AND 结果就不是 <code>TRUE</code>，而是 <strong>UNKNOWN</strong>，最终这条记录就被过滤掉。</p>
<p>举例：</p>
<ul>
<li><code>col1 = 10</code><br> 检查 <code>10 &lt;&gt; 5</code> → TRUE<br> 检查 <code>10 &lt;&gt; NULL</code> → UNKNOWN<br> <code>TRUE AND UNKNOWN</code> → UNKNOWN → 不返回</li>
</ul>
<p>所以只要子查询里有 <code>NULL</code>，所有外层行都会因为遇到 <code>UNKNOWN</code> 被排除掉，结果就是空集</p>
<p><strong>（2）一次扫 Orders 做条件聚合，再跟 Customers 关联</strong></p>
<pre><code class="language-sql">SELECT c.customer_id, c.customer_name
FROM Customers c
JOIN Orders o ON o.customer_id = c.customer_id
GROUP BY c.customer_id, c.customer_name
HAVING SUM(o.product_name = &#39;A&#39;) &gt; 0
   AND SUM(o.product_name = &#39;B&#39;) &gt; 0
   AND SUM(o.product_name = &#39;C&#39;) = 0
ORDER BY c.customer_id;
</code></pre>
<hr>
<h3 id="1112-每位学生的最高成绩"><a href="#1112-每位学生的最高成绩" class="headerlink" title="1112.每位学生的最高成绩"></a>1112.每位学生的最高成绩</h3><p>表：<code>Enrollments</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| student_id    | int     |
| course_id     | int     |
| grade         | int     |
+---------------+---------+
(student_id, course_id) 是该表的主键（具有唯一值的列的组合）。
grade 不会为 NULL。
</code></pre>
<p>编写解决方案，找出每位学生获得的最高成绩和它所对应的科目，若科目成绩并列，取 <code>course_id</code> 最小的一门。查询结果需按 <code>student_id</code> 增序进行排序。</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Enrollments 表：
+------------+-------------------+
| student_id | course_id | grade |
+------------+-----------+-------+
| 2          | 2         | 95    |
| 2          | 3         | 95    |
| 1          | 1         | 90    |
| 1          | 2         | 99    |
| 3          | 1         | 80    |
| 3          | 2         | 75    |
| 3          | 3         | 82    |
+------------+-----------+-------+
输出：
+------------+-------------------+
| student_id | course_id | grade |
+------------+-----------+-------+
| 1          | 2         | 99    |
| 2          | 2         | 95    |
| 3          | 3         | 82    |
+------------+-----------+-------+
</code></pre>
<p><strong>解答</strong>：</p>
<pre><code class="language-sql">select student_id, min(course_id)as course_id, grade from(
    select *, max(grade) over(partition by student_id) as max_score from Enrollments
)t where grade = max_score group by student_id, grade order by student_id;
</code></pre>
<hr>
<h3 id="1440-计算布尔表达式的值"><a href="#1440-计算布尔表达式的值" class="headerlink" title="1440.计算布尔表达式的值"></a>1440.计算布尔表达式的值</h3><p>表 <code>Variables</code>:</p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| name          | varchar |
| value         | int     |
+---------------+---------+
在 SQL 中，name 是该表主键.
该表包含了存储的变量及其对应的值.
</code></pre>
<p>表 <code>Expressions</code>:</p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| left_operand  | varchar |
| operator      | enum    |
| right_operand | varchar |
+---------------+---------+
在 SQL 中，(left_operand, operator, right_operand) 是该表主键.
该表包含了需要计算的布尔表达式.
operator 是枚举类型, 取值于(&#39;&lt;&#39;, &#39;&gt;&#39;, &#39;=&#39;)
left_operand 和 right_operand 的值保证存在于 Variables 表单中.
</code></pre>
<p>计算表 <code>Expressions</code> 中的布尔表达式。</p>
<p>返回的结果表 <strong>无顺序要求</strong> 。</p>
<p>结果格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Variables 表:
+------+-------+
| name | value |
+------+-------+
| x    | 66    |
| y    | 77    |
+------+-------+

Expressions 表:
+--------------+----------+---------------+
| left_operand | operator | right_operand |
+--------------+----------+---------------+
| x            | &gt;        | y             |
| x            | &lt;        | y             |
| x            | =        | y             |
| y            | &gt;        | x             |
| y            | &lt;        | x             |
| x            | =        | x             |
+--------------+----------+---------------+

输出:
+--------------+----------+---------------+-------+
| left_operand | operator | right_operand | value |
+--------------+----------+---------------+-------+
| x            | &gt;        | y             | false |
| x            | &lt;        | y             | true  |
| x            | =        | y             | false |
| y            | &gt;        | x             | true  |
| y            | &lt;        | x             | false |
| x            | =        | x             | true  |
+--------------+----------+---------------+-------+
解释：
如上所示, 你需要通过使用 Variables 表来找到 Expressions 表中的每一个布尔表达式的值.
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">SELECT e.left_operand,
       e.operator,
       e.right_operand,
       CASE
           WHEN e.operator = &#39;&gt;&#39; AND v1.value &gt; v2.value THEN &#39;true&#39;
           WHEN e.operator = &#39;&lt;&#39; AND v1.value &lt; v2.value THEN &#39;true&#39;
           WHEN e.operator = &#39;=&#39; AND v1.value = v2.value THEN &#39;true&#39;
           ELSE &#39;false&#39;
       END AS value
FROM Expressions e
JOIN Variables v1 ON e.left_operand = v1.name
JOIN Variables v2 ON e.right_operand = v2.name;
</code></pre>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li><code>JOIN Variables v1</code> → 获取左操作数的值。</li>
<li><code>JOIN Variables v2</code> → 获取右操作数的值。</li>
<li><code>CASE</code> 里根据不同运算符进行比较，返回 <code>true</code> 或 <code>false</code>。</li>
</ul>
<p>这样写就能正确对比 <strong>数值</strong>，而不是对比变量名字符串。</p>
<hr>
<h3 id="1212-查询球队积分（列转行）"><a href="#1212-查询球队积分（列转行）" class="headerlink" title="1212.查询球队积分（列转行）"></a>1212.查询球队积分（列转行）</h3><p>表: <code>Teams</code></p>
<pre><code>+---------------+----------+
| Column Name   | Type     |
+---------------+----------+
| team_id       | int      |
| team_name     | varchar  |
+---------------+----------+
team_id 是该表具有唯一值的列。
表中的每一行都代表一支独立足球队。
</code></pre>
<p>表: <code>Matches</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| match_id      | int     |
| host_team     | int     |
| guest_team    | int     | 
| host_goals    | int     |
| guest_goals   | int     |
+---------------+---------+
match_id 是该表具有唯一值的列。
表中的每一行都代表一场已结束的比赛。
比赛的主客队分别由它们自己的 id 表示，他们的进球由 host_goals 和 guest_goals 分别表示。
</code></pre>
<p>你希望在所有比赛之后计算所有球队的比分。积分奖励方式如下:</p>
<ul>
<li>如果球队赢了比赛(即比对手进更多的球)，就得 <strong>3</strong> 分。</li>
<li>如果双方打成平手(即，与对方得分相同)，则得 <strong>1</strong> 分。</li>
<li>如果球队输掉了比赛(例如，比对手少进球)，就 <strong>不得分</strong> 。</li>
</ul>
<p>编写解决方案，以找出每个队的 <code>team_id</code>，<code>team_name</code> 和 <code>num_points</code>。</p>
<p>返回的结果根据 <code>num_points</code> <strong>降序排序</strong>，如果有两队积分相同，那么这两队按 <code>team_id</code> <strong>升序排序</strong>。</p>
<p>返回结果格式如下。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Teams table:
+-----------+--------------+
| team_id   | team_name    |
+-----------+--------------+
| 10        | Leetcode FC  |
| 20        | NewYork FC   |
| 30        | Atlanta FC   |
| 40        | Chicago FC   |
| 50        | Toronto FC   |
+-----------+--------------+
Matches table:
+------------+--------------+---------------+-------------+--------------+
| match_id   | host_team    | guest_team    | host_goals  | guest_goals  |
+------------+--------------+---------------+-------------+--------------+
| 1          | 10           | 20            | 3           | 0            |
| 2          | 30           | 10            | 2           | 2            |
| 3          | 10           | 50            | 5           | 1            |
| 4          | 20           | 30            | 1           | 0            |
| 5          | 50           | 30            | 1           | 0            |
+------------+--------------+---------------+-------------+--------------+
输出：
+------------+--------------+---------------+
| team_id    | team_name    | num_points    |
+------------+--------------+---------------+
| 10         | Leetcode FC  | 7             |
| 20         | NewYork FC   | 3             |
| 50         | Toronto FC   | 3             |
| 30         | Atlanta FC   | 1             |
| 40         | Chicago FC   | 0             |
+------------+--------------+---------------+
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">
SELECT t.team_id,
       t.team_name,
       IFNULL(SUM(score), 0) AS num_points
FROM Teams t
LEFT JOIN (
    SELECT host_team AS team_id,
           CASE 
               WHEN host_goals &gt; guest_goals THEN 3
               WHEN host_goals = guest_goals THEN 1
               ELSE 0 
           END AS score
    FROM Matches
    UNION ALL
    SELECT guest_team AS team_id,
           CASE 
               WHEN guest_goals &gt; host_goals THEN 3
               WHEN guest_goals = host_goals THEN 1
               ELSE 0 
           END AS score
    FROM Matches
) m ON t.team_id = m.team_id
GROUP BY t.team_id, t.team_name
ORDER BY num_points DESC, t.team_id;
</code></pre>
<ul>
<li><p>没有结果（null）则返回0——&gt;IFNULL(col, 0)</p>
</li>
<li><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><ol>
<li><code>UNION ALL</code><ul>
<li>第一段取主队（<code>host_team</code>），根据比分计算积分。</li>
<li>第二段取客队（<code>guest_team</code>），同样计算积分。</li>
<li>这样每场比赛会贡献两行数据（主队、客队）。</li>
</ul>
</li>
<li>外层再 <code>JOIN Teams</code> → 确保所有球队都显示，即使一场没打过。</li>
<li><code>GROUP BY</code> 聚合积分，<code>ORDER BY num_points DESC, team_id</code> 保证排序符合要求。</li>
</ol>
</li>
</ul>
<p><strong>（列转行）分组后同一组的不同列数值要进行数学操作，可以用union all将不同列转换为同一列在行的方向拼接，再使用窗口函数得到结果</strong></p>
<hr>
<h3 id="1445-苹果和桔子（行转列）"><a href="#1445-苹果和桔子（行转列）" class="headerlink" title="1445. 苹果和桔子（行转列）"></a>1445. 苹果和桔子（行转列）</h3><p>表: <code>Sales</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| sale_date     | date    |
| fruit         | enum    | 
| sold_num      | int     | 
+---------------+---------+
(sale_date, fruit) 是该表主键(具有唯一值的列的组合)。
该表包含了每一天中&quot;苹果&quot; 和 &quot;桔子&quot;的销售情况。
</code></pre>
<p>编写解决方案报告每一天 <strong>苹果</strong> 和 <strong>桔子</strong> 销售的数目的差异.</p>
<p>返回的结果表, 按照格式为 (‘YYYY-MM-DD’) 的 <code>sale_date</code> 排序.</p>
<p>返回结果表如下例所示:</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Sales 表:
+------------+------------+-------------+
| sale_date  | fruit      | sold_num    |
+------------+------------+-------------+
| 2020-05-01 | apples     | 10          |
| 2020-05-01 | oranges    | 8           |
| 2020-05-02 | apples     | 15          |
| 2020-05-02 | oranges    | 15          |
| 2020-05-03 | apples     | 20          |
| 2020-05-03 | oranges    | 0           |
| 2020-05-04 | apples     | 15          |
| 2020-05-04 | oranges    | 16          |
+------------+------------+-------------+
输出：
+------------+--------------+
| sale_date  | diff         |
+------------+--------------+
| 2020-05-01 | 2            |
| 2020-05-02 | 0            |
| 2020-05-03 | 20           |
| 2020-05-04 | -1           |
+------------+--------------+
解释：
在 2020-05-01, 卖了 10 个苹果 和 8 个桔子 (差异为 10 - 8 = 2).
在 2020-05-02, 卖了 15 个苹果 和 15 个桔子 (差异为 15 - 15 = 0).
在 2020-05-03, 卖了 20 个苹果 和 0 个桔子 (差异为 20 - 0 = 20).
在 2020-05-04, 卖了 15 个苹果 和 16 个桔子 (差异为 15 - 16 = -1).
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select a.sale_date, a.sold_num - b.sold_num as diff
from Sales a left join Sales b
on a.sale_date = b.sale_date 
where a.fruit = &#39;apples&#39; and b.fruit = &#39;oranges&#39;;
</code></pre>
<p><strong>自连接数据表</strong><br> 把 <code>Sales</code> 表取两份：一份叫 <code>a</code>，一份叫 <code>b</code>，然后通过 <code>a.sale_date = b.sale_date</code> 把同一天的苹果和橘子配对到一起。</p>
<p><strong>限定水果种类</strong><br> 在 <code>where</code> 子句里规定：<code>a.fruit = &#39;apples&#39;</code>，<code>b.fruit = &#39;oranges&#39;</code>，这样就保证 <code>a</code> 表只取苹果的销售数据，<code>b</code> 表只取橘子的销售数据。</p>
<p><strong>计算销售差值</strong><br> 在 <code>select</code> 里取出日期 (<code>a.sale_date</code>)、苹果销量 (<code>a.sold_num</code>)、橘子销量 (<code>b.sold_num</code>)，并且计算它们的差值 <code>a.sold_num - b.sold_num</code>，命名为 <code>diff</code>。</p>
<p><strong>方法二：行转列</strong></p>
<pre><code class="language-sql">
select sale_date, (apple-orange)as diff from(
    select sale_date, max(case when fruit = &#39;apples&#39; then sold_num else 0 end) as apple, max(case when fruit = &#39;oranges&#39; then sold_num else 0 end)as orange from Sales group by sale_date
    )t;
</code></pre>
<hr>
<h3 id="1699-两人之间的通话次数"><a href="#1699-两人之间的通话次数" class="headerlink" title="1699.两人之间的通话次数"></a>1699.两人之间的通话次数</h3><p>表： <code>Calls</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| from_id     | int     |
| to_id       | int     |
| duration    | int     |
+-------------+---------+
该表没有主键(具有唯一值的列)，它可能包含重复项。
该表包含 from_id 与 to_id 间的一次电话的时长。
from_id != to_id
</code></pre>
<p>编写解决方案，统计每一对用户 <code>(person1, person2)</code> 之间的通话次数和通话总时长，其中 <code>person1 &lt; person2</code> 。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>返回结果格式如下示例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Calls 表：
+---------+-------+----------+
| from_id | to_id | duration |
+---------+-------+----------+
| 1       | 2     | 59       |
| 2       | 1     | 11       |
| 1       | 3     | 20       |
| 3       | 4     | 100      |
| 3       | 4     | 200      |
| 3       | 4     | 200      |
| 4       | 3     | 499      |
+---------+-------+----------+
输出：
+---------+---------+------------+----------------+
| person1 | person2 | call_count | total_duration |
+---------+---------+------------+----------------+
| 1       | 2       | 2          | 70             |
| 1       | 3       | 1          | 20             |
| 3       | 4       | 4          | 999            |
+---------+---------+------------+----------------+
解释：
用户 1 和 2 打过 2 次电话，总时长为 70 (59 + 11)。
用户 1 和 3 打过 1 次电话，总时长为 20。
用户 3 和 4 打过 4 次电话，总时长为 999 (100 + 200 + 200 + 499)。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select a as person1, b as person2, sum(total_count) as call_count, sum(total) as total_duration from(
select from_id as a, to_id as b, count(*) as total_count, sum(duration) as total from Calls group by
from_id, to_id 
union all
select to_id as a, from_id as b, count(*) as total_count, sum(duration) as total from Calls group by
to_id, from_id
)t where a &lt; b group by a, b;
</code></pre>
<p><strong>正反向通话拆开统计</strong><br> 先用 <code>from_id → to_id</code> 分组统计每一对通话的次数和总时长，再用 <code>to_id → from_id</code> 反向统计。<br> 这样做的目的是把双方互相拨打的情况都纳入考虑。</p>
<p><strong><code>union all</code> 合并结果</strong><br> 把正向和反向的结果拼在一起，形成一张“对称”的结果集。<br> 此时，每一对用户 (person1, person2) 会出现两次：一条是正向统计，一条是反向统计。</p>
<p><strong>统一顺序并再次聚合</strong><br> 在外层查询里，用 <code>where a &lt; b</code> 保证只保留 <code>(小id, 大id)</code> 的组合，消除顺序带来的重复。<br> 然后再按 <code>(a, b)</code> 分组，用 <code>sum(total_count)</code> 和 <code>sum(total)</code> 汇总双方的通话次数和总时长。</p>
<hr>
<h3 id="1501-可以放心投资的国家"><a href="#1501-可以放心投资的国家" class="headerlink" title="1501.可以放心投资的国家"></a>1501.可以放心投资的国家</h3><p>表 <code>Person</code>:</p>
<pre><code>+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| id             | int     |
| name           | varchar |
| phone_number   | varchar |
+----------------+---------+
id 是该表具有唯一值的列.
该表每一行包含一个人的名字和电话号码.
电话号码的格式是:&#39;xxx-yyyyyyy&#39;, 其中 xxx 是国家码(3 个字符), yyyyyyy 是电话号码(7 个字符), x 和 y 都表示数字. 同时, 国家码和电话号码都可以包含前导 0.
</code></pre>
<p>表 <code>Country</code>:</p>
<pre><code>+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| name           | varchar |
| country_code   | varchar |
+----------------+---------+
country_code 是该表具有唯一值的列.
该表每一行包含国家名和国家码. country_code 的格式是&#39;xxx&#39;, x 是数字.
</code></pre>
<p>表 <code>Calls</code>:</p>
<pre><code>+-------------+------+
| Column Name | Type |
+-------------+------+
| caller_id   | int  |
| callee_id   | int  |
| duration    | int  |
+-------------+------+
该表无主键, 可能包含重复行.
每一行包含呼叫方 id, 被呼叫方 id 和以分钟为单位的通话时长. caller_id != callee_id
</code></pre>
<p>一家电信公司想要投资新的国家。该公司想要投资的国家是: 该国的平均通话时长要严格地大于全球平均通话时长。</p>
<p>写一个解决方案, 找到所有该公司可以投资的国家。</p>
<p>返回的结果表 <strong>无顺序要求</strong>。</p>
<p>结果格式如下例所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Person 表：
+----+----------+--------------+
| id | name     | phone_number |
+----+----------+--------------+
| 3  | Jonathan | 051-1234567  |
| 12 | Elvis    | 051-7654321  |
| 1  | Moncef   | 212-1234567  |
| 2  | Maroua   | 212-6523651  |
| 7  | Meir     | 972-1234567  |
| 9  | Rachel   | 972-0011100  |
+----+----------+--------------+
Country 表:
+----------+--------------+
| name     | country_code |
+----------+--------------+
| Peru     | 051          |
| Israel   | 972          |
| Morocco  | 212          |
| Germany  | 049          |
| Ethiopia | 251          |
+----------+--------------+
Calls 表:
+-----------+-----------+----------+
| caller_id | callee_id | duration |
+-----------+-----------+----------+
| 1         | 9         | 33       |
| 2         | 9         | 4        |
| 1         | 2         | 59       |
| 3         | 12        | 102      |
| 3         | 12        | 330      |
| 12        | 3         | 5        |
| 7         | 9         | 13       |
| 7         | 1         | 3        |
| 9         | 7         | 1        |
| 1         | 7         | 7        |
+-----------+-----------+----------+
输出：
+----------+
| country  |
+----------+
| Peru     |
+----------+
解释：
国家 Peru 的平均通话时长是 (102 + 102 + 330 + 330 + 5 + 5) / 6 = 145.666667
国家 Israel 的平均通话时长是 (33 + 4 + 13 + 13 + 3 + 1 + 1 + 7) / 8 = 9.37500
国家 Morocco 的平均通话时长是 (33 + 4 + 59 + 59 + 3 + 7) / 6 = 27.5000 
全球平均通话时长 = (2 * (33 + 4 + 59 + 102 + 330 + 5 + 13 + 3 + 1 + 7)) / 20 = 55.70000
所以, Peru 是唯一的平均通话时长大于全球平均通话时长的国家, 也是唯一的推荐投资的国家.
</code></pre>
<p><strong>解答：</strong></p>
<p><strong>和上一题一个思路，将coller_id和collee_id通过union all转化到同一个表的同一列</strong></p>
<p>一个表（Calls）中出现两列（caller_id 、callee_id）都是同属一个表（Person）里的属性，用join+union即可全部归纳</p>
<pre><code class="language-sql">with base as(
    select c1.caller_id as id, c1.duration as phonetime, p1.phone_number as number from Calls c1 join Person p1 on c1.caller_id = p1.id 
    union all
    select c2.callee_id as id, c2.duration as phonetime, p2.phone_number as number from Calls c2 join Person p2 on c2.callee_id = p2.id 
),
seq as(
    select a.id, a.phonetime, b.name as country_name from base a join Country b on substring(a.number, 1, 3) = b.country_code 
),
country_avg as (
    select country_name, avg(phonetime) as avg_time from seq group by country_name
),
global_avg as (
    select avg(phonetime) as avg_global from seq 
)
select country_name as country from country_avg where avg_time &gt; (
    select avg_global from global_avg
</code></pre>
<ol>
<li><strong>提取国家代码</strong>：从<code>Person</code>表中提取每个用户的国家代码（电话号码的前三个字符）。</li>
<li><strong>计算每个通话的国家</strong>：对于<code>Calls</code>表中的每个通话，无论是呼叫者还是被呼叫者，都需要确定其国家代码，从而将通话时长分配给相应的国家。</li>
<li><strong>计算每个国家的平均通话时长</strong>：汇总每个国家的所有通话时长，计算其平均值。</li>
<li><strong>计算全球平均通话时长</strong>：汇总所有通话的通话时长，计算全球平均值。</li>
<li><strong>比较并筛选国家</strong>：筛选出那些平均通话时长严格大于全球平均通话时长的国家。</li>
</ol>
<hr>
<h3 id="1264-页面描述"><a href="#1264-页面描述" class="headerlink" title="1264.页面描述"></a>1264.页面描述</h3><p>朋友关系列表： <code>Friendship</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user1_id      | int     |
| user2_id      | int     |
+---------------+---------+
(user1_id, user2_id) 是这张表具有唯一值的列的组合。
这张表的每一行代表着 user1_id 和 user2_id 之间存在着朋友关系。
</code></pre>
<p>喜欢列表： <code>Likes</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| user_id     | int     |
| page_id     | int     |
+-------------+---------+
(user_id, page_id) 是这张表具有唯一值的列的组合。
这张表的每一行代表着 user_id 喜欢 page_id。
</code></pre>
<p>编写解决方案，向<code>user_id</code> &#x3D; 1 的用户，推荐其朋友们喜欢的页面。不要推荐该用户已经喜欢的页面。</p>
<p>以 <strong>任意顺序</strong> 返回结果，其中不应当包含重复项。</p>
<p>返回结果的格式如下例所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Friendship table:
+----------+----------+
| user1_id | user2_id |
+----------+----------+
| 1        | 2        |
| 1        | 3        |
| 1        | 4        |
| 2        | 3        |
| 2        | 4        |
| 2        | 5        |
| 6        | 1        |
+----------+----------+
 
Likes table:
+---------+---------+
| user_id | page_id |
+---------+---------+
| 1       | 88      |
| 2       | 23      |
| 3       | 24      |
| 4       | 56      |
| 5       | 11      |
| 6       | 33      |
| 2       | 77      |
| 3       | 77      |
| 6       | 88      |
+---------+---------+

输出：
+------------------+
| recommended_page |
+------------------+
| 23               |
| 24               |
| 56               |
| 33               |
| 77               |
+------------------+
解释：
用户1 同 用户2, 3, 4, 6 是朋友关系。
推荐页面为： 页面23 来自于 用户2, 页面24 来自于 用户3, 页面56 来自于 用户3 以及 页面33 来自于 用户6。
页面77 同时被 用户2 和 用户3 推荐。
页面88 没有被推荐，因为 用户1 已经喜欢了它。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">with base as(
    select case when user1_id = 1 then user2_id 
    when user2_id = 1 then user1_id else null end as friend from Friendship
),
seq as(
    select distinct a.page_id from Likes a join base b on a.user_id = b.friend where b.friend is not null
)
select page_id as recommended_page from seq a where not exists (
    select b.page_id from Likes b where b.user_id = 1 and a.page_id = b.page_id
);
</code></pre>
<p>如果等值子查询会返回null，则需要使用not exists+相关子查询</p>
<hr>
<h3 id="608-树节点"><a href="#608-树节点" class="headerlink" title="608.树节点"></a>608.树节点</h3><p>表：<code>Tree</code></p>
<pre><code>+-------------+------+
| Column Name | Type |
+-------------+------+
| id          | int  |
| p_id        | int  |
+-------------+------+
id 是该表中具有唯一值的列。
该表的每行包含树中节点的 id 及其父节点的 id 信息。
给定的结构总是一个有效的树。
</code></pre>
<p>树中的每个节点可以是以下三种类型之一：</p>
<ul>
<li><strong>“Leaf”</strong>：节点是叶子节点。</li>
<li><strong>“Root”</strong>：节点是树的根节点。</li>
<li><strong>“lnner”</strong>：节点既不是叶子节点也不是根节点。</li>
</ul>
<p>编写一个解决方案来报告树中每个节点的类型。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Tree table:
+----+------+
| id | p_id |
+----+------+
| 1  | null |
| 2  | 1    |
| 3  | 1    |
| 4  | 2    |
| 5  | 2    |
+----+------+
输出：
+----+-------+
| id | type  |
+----+-------+
| 1  | Root  |
| 2  | Inner |
| 3  | Leaf  |
| 4  | Leaf  |
| 5  | Leaf  |
+----+-------+
解释：
节点 1 是根节点，因为它的父节点为空，并且它有子节点 2 和 3。
节点 2 是一个内部节点，因为它有父节点 1 和子节点 4 和 5。
节点 3、4 和 5 是叶子节点，因为它们有父节点而没有子节点。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：
Tree table:
+----+------+
| id | p_id |
+----+------+
| 1  | null |
+----+------+
输出：
+----+-------+
| id | type  |
+----+-------+
| 1  | Root  |
+----+-------+
解释：如果树中只有一个节点，则只需要输出其根属性。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">
select id, case when p_id is null then &#39;Root&#39; 
when id in (select p_id from Tree where p_id is not null) then &#39;Inner&#39;
else &#39;Leaf&#39; end as type from Tree;
</code></pre>
<hr>
<h3 id="534-游戏玩法分析"><a href="#534-游戏玩法分析" class="headerlink" title="534.游戏玩法分析 |||"></a>534.游戏玩法分析 |||</h3><p>表：<code>Activity</code></p>
<pre><code>+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
（player_id，event_date）是此表的主键（具有唯一值的列）。
这张表显示了某些游戏的玩家的活动情况。
每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0 ）。
</code></pre>
<p>编写一个解决方案，同时报告每组玩家和日期，以及玩家到 <strong>目前为止</strong> 玩了多少游戏。也就是说，玩家在该日期之前所玩的游戏总数。详细情况请查看示例。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-05-02 | 6            |
| 1         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+
输出：
+-----------+------------+---------------------+
| player_id | event_date | games_played_so_far |
+-----------+------------+---------------------+
| 1         | 2016-03-01 | 5                   |
| 1         | 2016-05-02 | 11                  |
| 1         | 2017-06-25 | 12                  |
| 3         | 2016-03-02 | 0                   |
| 3         | 2018-07-03 | 5                   |
+-----------+------------+---------------------+
解释：
对于 ID 为 1 的玩家，2016-05-02 共玩了 5+6=11 个游戏，2017-06-25 共玩了 5+6+1=12 个游戏。
对于 ID 为 3 的玩家，2018-07-03 共玩了 0+5=5 个游戏。
请注意，对于每个玩家，我们只关心玩家的登录日期。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select player_id, event_date, sum(games_played)over (partition by player_id order by event_date)as games_played_so_far from Activity;
</code></pre>
<hr>
<h3 id="1783-大满贯数量"><a href="#1783-大满贯数量" class="headerlink" title="1783.大满贯数量"></a>1783.大满贯数量</h3><p>表：<code>Players</code></p>
<pre><code>+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| player_id      | int     |
| player_name    | varchar |
+----------------+---------+
player_id 是这个表的主键（具有唯一值的列）
这个表的每一行给出一个网球运动员的 ID 和 姓名
</code></pre>
<p>表：<code>Championships</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| year          | int     |
| Wimbledon     | int     |
| Fr_open       | int     |
| US_open       | int     |
| Au_open       | int     |
+---------------+---------+
year 是这个表的主键（具有唯一值的列）
该表的每一行都包含在每场大满贯网球比赛中赢得比赛的球员的 ID
</code></pre>
<p>编写解决方案，找出每一个球员赢得大满贯比赛的次数。结果不包含没有赢得比赛的球员的ID 。</p>
<p>结果集 <strong>无顺序要求</strong> 。</p>
<p>结果的格式，如下所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Players 表：
+-----------+-------------+
| player_id | player_name |
+-----------+-------------+
| 1         | Nadal       |
| 2         | Federer     |
| 3         | Novak       |
+-----------+-------------+
Championships 表：
+------+-----------+---------+---------+---------+
| year | Wimbledon | Fr_open | US_open | Au_open |
+------+-----------+---------+---------+---------+
| 2018 | 1         | 1       | 1       | 1       |
| 2019 | 1         | 1       | 2       | 2       |
| 2020 | 2         | 1       | 2       | 2       |
+------+-----------+---------+---------+---------+
输出：
+-----------+-------------+-------------------+
| player_id | player_name | grand_slams_count |
+-----------+-------------+-------------------+
| 2         | Federer     | 5                 |
| 1         | Nadal       | 7                 |
+-----------+-------------+-------------------+
解释：
Player 1 (Nadal) 获得了 7 次大满贯：其中温网 2 次(2018, 2019), 法国公开赛 3 次 (2018, 2019, 2020), 美国公开赛 1 次 (2018)以及澳网公开赛 1 次 (2018) 。
Player 2 (Federer) 获得了 5 次大满贯：其中温网 1 次 (2020), 美国公开赛 2 次 (2019, 2020) 以及澳网公开赛 2 次 (2019, 2020) 。
Player 3 (Novak)  没有赢得，因此不包含在结果集中。
</code></pre>
<p><strong>解答：</strong></p>
<p>我用的是列转行的思路进行解答，把比赛名这几列转为新列competition的不同行，把不同比赛的获胜id转为player_id的不同行。</p>
<pre><code class="language-sql">select a.player_id , a.player_name, count(b.player_id) as grand_slams_count from Players a right join(
select Wimbledon as player_id, &#39;Wimbledon&#39; as competition from Championships  
union all
select Fr_open as player_id, &#39;Fr_open&#39; as competition from Championships  
union all
select US_open as player_id, &#39;US_open&#39; as competition from Championships  
union all
select Au_open as player_id, &#39;Au_open&#39; as competition from Championships )b 
on a.player_id = b.player_id group by b.player_id;
</code></pre>
<hr>
<h3 id="1747-应该被禁止的Leetflex账户"><a href="#1747-应该被禁止的Leetflex账户" class="headerlink" title="1747..应该被禁止的Leetflex账户"></a>1747..应该被禁止的Leetflex账户</h3><p>表: <code>LogInfo</code></p>
<pre><code>+-------------+----------+
| Column Name | Type     |
+-------------+----------+
| account_id  | int      |
| ip_address  | int      |
| login       | datetime |
| logout      | datetime |
+-------------+----------+
该表可能包含重复项。
该表包含有关Leetflex帐户的登录和注销日期的信息。 它还包含了该账户用于登录和注销的网络地址的信息。
题目确保每一个注销时间都在登录时间之后。
</code></pre>
<p>编写解决方案，查找那些应该被禁止的Leetflex帐户编号 <code>account_id</code> 。 如果某个帐户在某一时刻从两个不同的网络地址登录了，则这个帐户应该被禁止。</p>
<p>可以以 <strong>任何顺序</strong> 返回结果。</p>
<p>查询结果格式如下例所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
LogInfo table:
+------------+------------+---------------------+---------------------+
| account_id | ip_address | login               | logout              |
+------------+------------+---------------------+---------------------+
| 1          | 1          | 2021-02-01 09:00:00 | 2021-02-01 09:30:00 |
| 1          | 2          | 2021-02-01 08:00:00 | 2021-02-01 11:30:00 |
| 2          | 6          | 2021-02-01 20:30:00 | 2021-02-01 22:00:00 |
| 2          | 7          | 2021-02-02 20:30:00 | 2021-02-02 22:00:00 |
| 3          | 9          | 2021-02-01 16:00:00 | 2021-02-01 16:59:59 |
| 3          | 13         | 2021-02-01 17:00:00 | 2021-02-01 17:59:59 |
| 4          | 10         | 2021-02-01 16:00:00 | 2021-02-01 17:00:00 |
| 4          | 11         | 2021-02-01 17:00:00 | 2021-02-01 17:59:59 |
+------------+------------+---------------------+---------------------+
输出：
+------------+
| account_id |
+------------+
| 1          |
| 4          |
+------------+
解释：
Account ID 1 --&gt; 该账户从 &quot;2021-02-01 09:00:00&quot; 到 &quot;2021-02-01 09:30:00&quot; 在两个不同的网络地址(1 and 2)上激活了。它应该被禁止.
Account ID 2 --&gt; 该账户在两个不同的网络地址 (6, 7) 激活了，但在不同的时间上.
Account ID 3 --&gt; 该账户在两个不同的网络地址 (9, 13) 激活了，虽然是同一天，但时间上没有交集.
Account ID 4 --&gt; 该账户从 &quot;2021-02-01 17:00:00&quot; 到 &quot;2021-02-01 17:00:00&quot; 在两个不同的网络地址 (10 and 11)上激活了。它应该被禁止.
</code></pre>
<p><strong>解答：</strong></p>
<p>同一个id的不同列数值进行对比——&gt;使用自连接。</p>
<p>注意：使用join时on的条件越少效率越高。</p>
<pre><code class="language-sql">select account_id from (
select max(case when b.login &gt; a.login and b.login &lt;= a.logout then a.account_id else 0 end) as account_id
from LogInfo a join LogInfo b on a.account_id = b.account_id where a.ip_address != b.ip_address group by a.account_id)t where account_id &gt; 0;
</code></pre>
<p>若把a.ip_address !&#x3D; b.ip_address写到on中则会报超时</p>
<pre><code class="language-sql">from LogInfo a join LogInfo b on a.account_id = b.account_id and a.ip_address != b.ip_address group by a.account_id)t where account_id &gt; 0;
</code></pre>
<hr>
<h3 id="184-部门工资最高的员工"><a href="#184-部门工资最高的员工" class="headerlink" title="184.部门工资最高的员工"></a>184.部门工资最高的员工</h3><p>表： <code>Employee</code></p>
<pre><code>+--------------+---------+
| 列名          | 类型    |
+--------------+---------+
| id           | int     |
| name         | varchar |
| salary       | int     |
| departmentId | int     |
+--------------+---------+
在 SQL 中，id是此表的主键。
departmentId 是 Department 表中 id 的外键（在 Pandas 中称为 join key）。
此表的每一行都表示员工的 id、姓名和工资。它还包含他们所在部门的 id。
</code></pre>
<p>表： <code>Department</code></p>
<pre><code>+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| id          | int     |
| name        | varchar |
+-------------+---------+
在 SQL 中，id 是此表的主键列。
此表的每一行都表示一个部门的 d 及其名称。
</code></pre>
<p>查找出每个部门中薪资最高的员工。<br>按 <strong>任意顺序</strong> 返回结果表。<br>查询结果格式如下例所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Employee 表:
+----+-------+--------+--------------+
| id | name  | salary | departmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Jim   | 90000  | 1            |
| 3  | Henry | 80000  | 2            |
| 4  | Sam   | 60000  | 2            |
| 5  | Max   | 90000  | 1            |
+----+-------+--------+--------------+
Department 表:
+----+-------+
| id | name  |
+----+-------+
| 1  | IT    |
| 2  | Sales |
+----+-------+
输出：
+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Jim      | 90000  |
| Sales      | Henry    | 80000  |
| IT         | Max      | 90000  |
+------------+----------+--------+
解释：Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select b.name as Department, a.name as Employee, a.salary as Salary from (select *, RANK() over(partition by departmentId order by salary DESC) as rk from Employee) a join Department b on a.departmentId = b.id where a.rk = 1;
</code></pre>
<hr>
<h3 id="1549-每件商品的最新订单"><a href="#1549-每件商品的最新订单" class="headerlink" title="1549.每件商品的最新订单"></a>1549.每件商品的最新订单</h3><p>表: <code>Customers</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| customer_id   | int     |
| name          | varchar |
+---------------+---------+
customer_id 是该表主键.
该表包含消费者的信息.
</code></pre>
<p>表: <code>Orders</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| customer_id   | int     |
| product_id    | int     |
+---------------+---------+
order_id 是该表主键.
该表包含消费者customer_id产生的订单.
不会有商品被相同的用户在一天内下单超过一次.
</code></pre>
<p>表: <code>Products</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| product_name  | varchar |
| price         | int     |
+---------------+---------+
product_id 是该表主键.
该表包含所有商品的信息.
</code></pre>
<p>写一个解决方案, 找到每件商品的最新订单(可能有多个).</p>
<p>返回的结果以 <code>product_name</code> <strong>升序排列</strong>, 如果有排序相同, 再以 <code>product_id</code> <strong>升序</strong>排列. 如果还有排序相同, 再以 <code>order_id</code> <strong>升序</strong>排列.</p>
<p>查询结果格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入:
Customers表：
+-------------+-----------+
| customer_id | name      |
+-------------+-----------+
| 1           | Winston   |
| 2           | Jonathan  |
| 3           | Annabelle |
| 4           | Marwan    |
| 5           | Khaled    |
+-------------+-----------+
Orders表：
+----------+------------+-------------+------------+
| order_id | order_date | customer_id | product_id |
+----------+------------+-------------+------------+
| 1        | 2020-07-31 | 1           | 1          |
| 2        | 2020-07-30 | 2           | 2          |
| 3        | 2020-08-29 | 3           | 3          |
| 4        | 2020-07-29 | 4           | 1          |
| 5        | 2020-06-10 | 1           | 2          |
| 6        | 2020-08-01 | 2           | 1          |
| 7        | 2020-08-01 | 3           | 1          |
| 8        | 2020-08-03 | 1           | 2          |
| 9        | 2020-08-07 | 2           | 3          |
| 10       | 2020-07-15 | 1           | 2          |
+----------+------------+-------------+------------+
Products表：
+------------+--------------+-------+
| product_id | product_name | price |
+------------+--------------+-------+
| 1          | keyboard     | 120   |
| 2          | mouse        | 80    |
| 3          | screen       | 600   |
| 4          | hard disk    | 450   |
+------------+--------------+-------+
输出：
+--------------+------------+----------+------------+
| product_name | product_id | order_id | order_date |
+--------------+------------+----------+------------+
| keyboard     | 1          | 6        | 2020-08-01 |
| keyboard     | 1          | 7        | 2020-08-01 |
| mouse        | 2          | 8        | 2020-08-03 |
| screen       | 3          | 3        | 2020-08-29 |
+--------------+------------+----------+------------+
解释：
keyboard 的最新订单在2020-08-01, 在这天有两次下单.
mouse 的最新订单在2020-08-03, 在这天只有一次下单.
screen 的最新订单在2020-08-29, 在这天只有一次下单.
hard disk 没有被下单, 我们不把它包含在结果表中.
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select a.product_name, a.product_id, b.order_id, b.order_date from Products a left join (select order_date, order_id, product_id, max(order_date) over(partition by product_id) as max_order from Orders)b on a.product_id = b.product_id where b.order_date = b.max_order order by product_name, product_id, order_id;
</code></pre>
<hr>
<h3 id="1532-最近的三笔订单"><a href="#1532-最近的三笔订单" class="headerlink" title="1532.最近的三笔订单"></a>1532.最近的三笔订单</h3><p>表：<code>Customers</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| customer_id   | int     |
| name          | varchar |
+---------------+---------+
customer_id 是该表具有唯一值的列
该表包含消费者的信息
</code></pre>
<p>表：<code>Orders</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| customer_id   | int     |
| cost          | int     |
+---------------+---------+
order_id 是该表具有唯一值的列
该表包含 id 为 customer_id 的消费者的订单信息
每一个消费者 每天一笔订单
</code></pre>
<p>写一个解决方案，找到每个用户的最近三笔订单。如果用户的订单少于 3 笔，则返回他的全部订单。</p>
<p>返回的结果按照 <code>customer_name</code> <strong>升序</strong> 排列。如果有相同的排名，则按照 <code>customer_id</code> <strong>升序</strong> 排列。如果排名还有相同，则按照 <code>order_date</code> <strong>降序</strong> 排列。</p>
<p>结果格式如下例所示：</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Customers
+-------------+-----------+
| customer_id | name      |
+-------------+-----------+
| 1           | Winston   |
| 2           | Jonathan  |
| 3           | Annabelle |
| 4           | Marwan    |
| 5           | Khaled    |
+-------------+-----------+

Orders
+----------+------------+-------------+------+
| order_id | order_date | customer_id | cost |
+----------+------------+-------------+------+
| 1        | 2020-07-31 | 1           | 30   |
| 2        | 2020-07-30 | 2           | 40   |
| 3        | 2020-07-31 | 3           | 70   |
| 4        | 2020-07-29 | 4           | 100  |
| 5        | 2020-06-10 | 1           | 1010 |
| 6        | 2020-08-01 | 2           | 102  |
| 7        | 2020-08-01 | 3           | 111  |
| 8        | 2020-08-03 | 1           | 99   |
| 9        | 2020-08-07 | 2           | 32   |
| 10       | 2020-07-15 | 1           | 2    |
+----------+------------+-------------+------+
输出：
+---------------+-------------+----------+------------+
| customer_name | customer_id | order_id | order_date |
+---------------+-------------+----------+------------+
| Annabelle     | 3           | 7        | 2020-08-01 |
| Annabelle     | 3           | 3        | 2020-07-31 |
| Jonathan      | 2           | 9        | 2020-08-07 |
| Jonathan      | 2           | 6        | 2020-08-01 |
| Jonathan      | 2           | 2        | 2020-07-30 |
| Marwan        | 4           | 4        | 2020-07-29 |
| Winston       | 1           | 8        | 2020-08-03 |
| Winston       | 1           | 1        | 2020-07-31 |
| Winston       | 1           | 10       | 2020-07-15 |
+---------------+-------------+----------+------------+
解释：
Winston 有 4 笔订单, 排除了 &quot;2020-06-10&quot; 的订单, 因为它是最老的订单。
Annabelle 只有 2 笔订单, 全部返回。
Jonathan 恰好有 3 笔订单。
Marwan 只有 1 笔订单。
结果表我们按照 customer_name 升序排列，customer_id 升序排列，order_date 降序排列。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select a.name as customer_name, a.customer_id, b.order_id, b.order_date from Customers a left join (
select *, rank() over(partition by customer_id order by order_date DESC)as rk from Orders )b on 
a.customer_id = b.customer_id where rk &lt;= 3 order by customer_name, customer_id, order_date DESC;
</code></pre>
<hr>
<h3 id="1831-每天的最大交易"><a href="#1831-每天的最大交易" class="headerlink" title="1831.每天的最大交易"></a>1831.每天的最大交易</h3><p>表：<code>Transactions</code></p>
<pre><code>+----------------+----------+
| Column Name    | Type     |
+----------------+----------+
| transaction_id | int      |
| day            | datetime |
| amount         | int      |
+----------------+----------+
transaction_id 是该表具有唯一值的列。
每行包括了该次交易的信息。
</code></pre>
<p>编写一个解决方案，报告每天交易金额 <code>amount</code> <strong>最大</strong> 的交易 ID 。如果一天中有多个这样的交易，返回这些交易的 ID 。</p>
<p>返回结果根据 <code>transaction_id</code> <strong>升序排列</strong>。</p>
<p>返回格式如下示例所示：</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Transactions table:
+----------------+--------------------+--------+
| transaction_id | day                | amount |
+----------------+--------------------+--------+
| 8              | 2021-4-3 15:57:28  | 57     |
| 9              | 2021-4-28 08:47:25 | 21     |
| 1              | 2021-4-29 13:28:30 | 58     |
| 5              | 2021-4-28 16:39:59 | 40     |
| 6              | 2021-4-29 23:39:28 | 58     |
+----------------+--------------------+--------+
输出：
+----------------+
| transaction_id |
+----------------+
| 1              |
| 5              |
| 6              |
| 8              |
+----------------+
解释：
&quot;2021-4-3&quot;  --&gt; 有一个 id 是 8 的交易，因此，把它加入结果表。 
&quot;2021-4-28&quot; --&gt; 有两个交易，id 是 5 和 9 ，交易 5 的金额是 40 ，而交易 9 的数量是 21 。只需要将交易 5 加入结果表，因为它是当天金额最大的交易。
&quot;2021-4-29&quot; --&gt; 有两个交易，id 是 1 和 6 ，这两个交易的金额都是 58 ，因此需要把它们都写入结果表。
最后，把交易 id 按照升序排列。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select transaction_id from (
select *, rank() over(partition by DAY(day) order by amount DESC) as rk from Transactions)t 
where rk = 1 order by transaction_id;
</code></pre>
<hr>
<h3 id="1285-找到连续区间的开始和结束数字"><a href="#1285-找到连续区间的开始和结束数字" class="headerlink" title="1285.找到连续区间的开始和结束数字"></a>1285.找到连续区间的开始和结束数字</h3><p>表：<code>Logs</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| log_id        | int     |
+---------------+---------+
id 是上表具有唯一值的列。
上表的每一行包含日志表中的一个 ID。
</code></pre>
<p>编写解决方案，得到 <code>Logs</code> 表中的连续区间的开始数字和结束数字。</p>
<p>返回结果表按照 <code>start_id</code> 排序。</p>
<p>结果格式如下面的例子。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Logs 表：
+------------+
| log_id     |
+------------+
| 1          |
| 2          |
| 3          |
| 7          |
| 8          |
| 10         |
+------------+
输出：
+------------+--------------+
| start_id   | end_id       |
+------------+--------------+
| 1          | 3            |
| 7          | 8            |
| 10         | 10           |
+------------+--------------+
解释：
结果表应包含 Logs 表中的所有区间。
从 1 到 3 在表中。
从 4 到 6 不在表中。
从 7 到 8 在表中。
9 不在表中。
10 在表中。
</code></pre>
<p><strong>解答：</strong></p>
<p>连续区间：用row_number构造排序数字rk，用log_id减去rk得差值diff，相同差值diff代表同一连续区间</p>
<pre><code class="language-sql">with base as(
    select *, row_number() over (order by log_id) as rk from Logs 
),
seq as(
    select log_id, log_id - rk as diff from base 
)
select distinct min(log_id)over (partition by diff) as start_id, max(log_id) over(partition by diff)as end_id from
seq; 
</code></pre>
<hr>
<h3 id="1596-每位顾客最经常订购的商品（易）"><a href="#1596-每位顾客最经常订购的商品（易）" class="headerlink" title="1596. 每位顾客最经常订购的商品（易）"></a>1596. 每位顾客最经常订购的商品（易）</h3><p>表：<code>Customers</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| customer_id   | int     |
| name          | varchar |
+---------------+---------+
customer_id 是该表具有唯一值的列
该表包含所有顾客的信息
</code></pre>
<p>表：<code>Orders</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| customer_id   | int     |
| product_id    | int     |
+---------------+---------+
order_id 是该表具有唯一值的列
该表包含顾客 customer_id 的订单信息
没有顾客会在一天内订购相同的商品 多于一次
</code></pre>
<p>表：<code>Products</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| product_name  | varchar |
| price         | int     |
+---------------+---------+
product_id 是该表具有唯一值的列
该表包含了所有商品的信息
</code></pre>
<p>写一个解决方案，找到每一个顾客最经常订购的商品。</p>
<p>结果表单应该有每一位至少下过一次单的顾客 <code>customer_id</code> , 他最经常订购的商品的 <code>product_id</code> 和 <code>product_name</code>。</p>
<p>返回结果 <strong>没有顺序要求</strong>。</p>
<p>查询结果格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Customers表：
+-------------+-------+
| customer_id | name  |
+-------------+-------+
| 1           | Alice |
| 2           | Bob   |
| 3           | Tom   |
| 4           | Jerry |
| 5           | John  |
+-------------+-------+
Orders表：
+----------+------------+-------------+------------+
| order_id | order_date | customer_id | product_id |
+----------+------------+-------------+------------+
| 1        | 2020-07-31 | 1           | 1          |
| 2        | 2020-07-30 | 2           | 2          |
| 3        | 2020-08-29 | 3           | 3          |
| 4        | 2020-07-29 | 4           | 1          |
| 5        | 2020-06-10 | 1           | 2          |
| 6        | 2020-08-01 | 2           | 1          |
| 7        | 2020-08-01 | 3           | 3          |
| 8        | 2020-08-03 | 1           | 2          |
| 9        | 2020-08-07 | 2           | 3          |
| 10       | 2020-07-15 | 1           | 2          |
+----------+------------+-------------+------------+
Products表：
+------------+--------------+-------+
| product_id | product_name | price |
+------------+--------------+-------+
| 1          | keyboard     | 120   |
| 2          | mouse        | 80    |
| 3          | screen       | 600   |
| 4          | hard disk    | 450   |
+------------+--------------+-------+
输出：
+-------------+------------+--------------+
| customer_id | product_id | product_name |
+-------------+------------+--------------+
| 1           | 2          | mouse        |
| 2           | 1          | keyboard     |
| 2           | 2          | mouse        |
| 2           | 3          | screen       |
| 3           | 3          | screen       |
| 4           | 1          | keyboard     |
+-------------+------------+--------------+
解释：
Alice (customer 1) 三次订购鼠标, 一次订购键盘, 所以鼠标是 Alice 最经常订购的商品.
Bob (customer 2) 一次订购键盘, 一次订购鼠标, 一次订购显示器, 所以这些都是 Bob 最经常订购的商品.
Tom (customer 3) 只两次订购显示器, 所以显示器是 Tom 最经常订购的商品.
Jerry (customer 4) 只一次订购键盘, 所以键盘是 Jerry 最经常订购的商品.
John (customer 5) 没有订购过商品, 所以我们并没有把 John 包含在结果表中.
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">
with base as(
    select customer_id, product_id, count(*) as ct from Orders group by customer_id, product_id
),
seq as(
    select *, rank() over (partition by customer_id order by ct DESC) as rk from base 
)
select a.customer_id, a.product_id, b.product_name from seq a left join Products b on a.product_id = b.product_id where rk = 1;
</code></pre>
<hr>
<h3 id="1709-访问日期之间最大的空档期"><a href="#1709-访问日期之间最大的空档期" class="headerlink" title="1709. 访问日期之间最大的空档期"></a>1709. 访问日期之间最大的空档期</h3><p>表： <code>UserVisits</code></p>
<pre><code>+-------------+------+
| Column Name | Type |
+-------------+------+
| user_id     | int  |
| visit_date  | date |
+-------------+------+
该表没有主键，它可能有重复的行
该表包含用户访问某特定零售商的日期日志。
</code></pre>
<p>假设今天的日期是 <code>&#39;2021-1-1&#39;</code> 。</p>
<p>编写解决方案，对于每个 <code>user_id</code> ，求出每次访问及其下一个访问（若该次访问是最后一次，则为今天）之间最大的空档期天数 <code>window</code> 。</p>
<p>返回结果表，按用户编号 <code>user_id</code> 排序。</p>
<p>结果格式如下示例所示：</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
UserVisits 表：
+---------+------------+
| user_id | visit_date |
+---------+------------+
| 1       | 2020-11-28 |
| 1       | 2020-10-20 |
| 1       | 2020-12-3  |
| 2       | 2020-10-5  |
| 2       | 2020-12-9  |
| 3       | 2020-11-11 |
+---------+------------+
输出：
+---------+---------------+
| user_id | biggest_window|
+---------+---------------+
| 1       | 39            |
| 2       | 65            |
| 3       | 51            |
+---------+---------------+
解释：
对于第一个用户，问题中的空档期在以下日期之间：
    - 2020-10-20 至 2020-11-28 ，共计 39 天。
    - 2020-11-28 至 2020-12-3 ，共计 5 天。
    - 2020-12-3 至 2021-1-1 ，共计 29 天。
由此得出，最大的空档期为 39 天。
对于第二个用户，问题中的空档期在以下日期之间：
    - 2020-10-5 至 2020-12-9 ，共计 65 天。
    - 2020-12-9 至 2021-1-1 ，共计 23 天。
由此得出，最大的空档期为 65 天。
对于第三个用户，问题中的唯一空档期在 2020-11-11 至 2021-1-1 之间，共计 51 天。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">with base as(
    select user_id, visit_date, IFNULL(lead(visit_date, 1) over (partition by user_id order by visit_date), &#39;2021-1-1&#39;)as next_date from UserVisits 
),
seq as (
    select *, datediff(next_date, visit_date) as diff from base 
)
select distinct user_id, diff as biggest_window from (
    select user_id, diff, max(diff) over(partition by user_id) as mx_diff from seq)t where diff = mx_diff;
</code></pre>
<hr>
<h3 id="1270-向公司CEO汇报工作的所有人"><a href="#1270-向公司CEO汇报工作的所有人" class="headerlink" title="1270. 向公司CEO汇报工作的所有人"></a>1270. 向公司CEO汇报工作的所有人</h3><p>员工表：<code>Employees</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| employee_id   | int     |
| employee_name | varchar |
| manager_id    | int     |
+---------------+---------+
employee_id 是这个表具有唯一值的列。
这个表中每一行中，employee_id 表示职工的 ID，employee_name 表示职工的名字，manager_id 表示该职工汇报工作的直线经理。
这个公司 CEO 是 employee_id = 1 的人。
</code></pre>
<p>编写解决方案，找出所有直接或间接向公司 CEO 汇报工作的职工的 <code>employee_id</code> 。</p>
<p>由于公司规模较小，经理之间的间接关系 <strong>不超过 3 个经理</strong> 。</p>
<p>可以以 <strong>任何顺序</strong> 返回无重复项的结果。</p>
<p>返回结果示例如下。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Employees table:
+-------------+---------------+------------+
| employee_id | employee_name | manager_id |
+-------------+---------------+------------+
| 1           | Boss          | 1          |
| 3           | Alice         | 3          |
| 2           | Bob           | 1          |
| 4           | Daniel        | 2          |
| 7           | Luis          | 4          |
| 8           | Jhon          | 3          |
| 9           | Angela        | 8          |
| 77          | Robert        | 1          |
+-------------+---------------+------------+
输出：
+-------------+
| employee_id |
+-------------+
| 2           |
| 77          |
| 4           |
| 7           |
+-------------+
解释：
公司 CEO 的 employee_id 是 1.
employee_id 是 2 和 77 的职员直接汇报给公司 CEO。
employee_id 是 4 的职员间接汇报给公司 CEO 4 --&gt; 2 --&gt; 1 。
employee_id 是 7 的职员间接汇报给公司 CEO 7 --&gt; 4 --&gt; 2 --&gt; 1 。
employee_id 是 3, 8 ，9 的职员不会直接或间接的汇报给公司 CEO。 
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">with base1 as (
    select employee_id from Employees where manager_id = 1 and employee_id != 1
),
base as(
    select a.employee_id from Employees a join base1 b on a.manager_id = b.employee_id
)
select c.employee_id from Employees c join base d on c.manager_id = d.employee_id
union all 
select * from base
union all 
select * from base1;
</code></pre>
<p>补充：</p>
<p>将null转化为0——&gt;IFNULL(a.column, 0)</p>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 KING!BOB!
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;KING BOB
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    <canvas
    id="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>
    <canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="Jack-Li-Npu/comment"
    data-repo-id="R_kgDOPviQNg"
    data-category="Announcements"
    data-category-id="DIC_kwDOPviQNs4Cva-O"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang=""
    crossorigin
    async
></script>





    
<!-- hexo injector body_end start --><script data-pjax src="https://unpkg.com/oh-my-live2d"></script><script>const oml2d = OML2D.loadOml2d({dockedPosition:"right",mobileDisplay:true,models:[{"path":"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","mobilePosition":[-10,23],"mobileScale":0.1,"mobileStageStyle":{"width":180,"height":166},"motionPreloadStrategy":"IDLE","position":[-10,35],"scale":0.15,"stageStyle":{"width":250,"height":250}},{"path":"https://unpkg.com/live2d-widget-model-koharu@1.0.5/assets/koharu.model.json","scale":0.12,"position":[0,0],"stageStyle":{"width":250},"mobileScale":0.08,"mobilePosition":[0,0],"mobileStageStyle":{"width":180}},{"path":"https://unpkg.com/live2d-widget-model-haruto@1.0.5/assets/haruto.model.json","scale":0.12,"position":[0,0],"mobileScale":0.08,"mobilePosition":[0,0],"mobileStageStyle":{"width":180},"stageStyle":{"width":250}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:false,tips:{style: {"width":230,"height":120,"left":"calc(50% - 20px)","top":"-100px"},mobileStyle: {"width":180,"height":80,"left":"calc(50% - 30px)","top":"-100px"},idleTips:{interval:15000,message:function(){
  return axios.get('https://v1.hitokoto.cn?c=i')
    .then(function (response) {
      return response.data.hitokoto ;
    })
    .catch(function (error) {
      console.error(error);
    });
}
}}});</script><!-- hexo injector body_end end --></body>
</html>
