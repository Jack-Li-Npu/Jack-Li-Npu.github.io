
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>Leetcode sql题目记录 | KING!BOB!</title>
    <meta name="author" content="KING BOB" />
    <meta name="description" content="LET'S MAKE IT HAPPEN" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/pic.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>KING!BOB!</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;KING!BOB!</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>Leetcode sql题目记录</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/5/26
        </span>
        
        <span class="category">
            <a href="/categories/Leetcode/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Leetcode
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/Leetcode/" style="color: #03a9f4">
                    Leetcode
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/SQL/" style="color: #ffa2c4">
                    SQL
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="Leetcode-sql题目记录"><a href="#Leetcode-sql题目记录" class="headerlink" title="Leetcode  sql题目记录"></a>Leetcode  sql题目记录</h2><p>本博客仅记录**高频 SQL 50 题（基础版）**中的中等难度题目，后续不定期更新</p>
<h3 id="570-至少有5名直接下属的经理"><a href="#570-至少有5名直接下属的经理" class="headerlink" title="570. 至少有5名直接下属的经理"></a>570. 至少有5名直接下属的经理</h3><p>表: <code>Employee</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| name        | varchar |
| department  | varchar |
| managerId   | int     |
+-------------+---------+
id 是此表的主键（具有唯一值的列）。
该表的每一行表示雇员的名字、他们的部门和他们的经理的id。
如果managerId为空，则该员工没有经理。
没有员工会成为自己的管理者。
</code></pre>
<p>编写一个解决方案，找出至少有<strong>五个直接下属</strong>的经理。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 
Employee 表:
+-----+-------+------------+-----------+
| id  | name  | department | managerId |
+-----+-------+------------+-----------+
| 101 | John  | A          | Null      |
| 102 | Dan   | A          | 101       |
| 103 | James | A          | 101       |
| 104 | Amy   | A          | 101       |
| 105 | Anne  | A          | 101       |
| 106 | Ron   | B          | 101       |
+-----+-------+------------+-----------+
输出: 
+------+
| name |
+------+
| John |
+------+
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">select a.name from Employee a join Employee b on a.id = b.managerId group by a.id having count(*) &gt;= 5;
</code></pre>
<p>没有 <code>GROUP BY</code><br> <code>HAVING</code> 是对<strong>分组后的结果</strong>过滤的。你没分组时，MySQL把整张结果集当成<strong>一个大组</strong>，<code>COUNT(a.id)</code> 统计的是<strong>所有经理–下属配对的总行数</strong>，不是“每个经理的下属数”。因此当测试数据里只有一个经理且刚好有 5 个下属时看起来“正确”，但只要有两个经理，合计行数 ≥5，你这句就会把两位经理都放进结果里，甚至还会重复多行。</p>
<hr>
<h3 id="1934-确认率"><a href="#1934-确认率" class="headerlink" title="1934. 确认率"></a>1934. 确认率</h3><p>表: <code>Signups</code></p>
<pre><code>+----------------+----------+
| Column Name    | Type     |
+----------------+----------+
| user_id        | int      |
| time_stamp     | datetime |
+----------------+----------+
User_id是该表的主键。
每一行都包含ID为user_id的用户的注册时间信息。
</code></pre>
<p>表: <code>Confirmations</code></p>
<pre><code>+----------------+----------+
| Column Name    | Type     |
+----------------+----------+
| user_id        | int      |
| time_stamp     | datetime |
| action         | ENUM     |
+----------------+----------+
(user_id, time_stamp)是该表的主键。
user_id是一个引用到注册表的外键。
action是类型为(&#39;confirmed&#39;， &#39;timeout&#39;)的ENUM
该表的每一行都表示ID为user_id的用户在time_stamp请求了一条确认消息，该确认消息要么被确认(&#39;confirmed&#39;)，要么被过期(&#39;timeout&#39;)。
</code></pre>
<p>用户的 <strong>确认率</strong> 是 <code>&#39;confirmed&#39;</code> 消息的数量除以请求的确认消息的总数。没有请求任何确认消息的用户的确认率为 <code>0</code> 。确认率四舍五入到 <strong>小数点后两位</strong> 。</p>
<p>编写一个SQL查询来查找每个用户的 确认率 。</p>
<p>以 任意顺序 返回结果表。</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例1:</strong></p>
<pre><code>输入：
Signups 表:
+---------+---------------------+
| user_id | time_stamp          |
+---------+---------------------+
| 3       | 2020-03-21 10:16:13 |
| 7       | 2020-01-04 13:57:59 |
| 2       | 2020-07-29 23:09:44 |
| 6       | 2020-12-09 10:39:37 |
+---------+---------------------+
Confirmations 表:
+---------+---------------------+-----------+
| user_id | time_stamp          | action    |
+---------+---------------------+-----------+
| 3       | 2021-01-06 03:30:46 | timeout   |
| 3       | 2021-07-14 14:00:00 | timeout   |
| 7       | 2021-06-12 11:57:29 | confirmed |
| 7       | 2021-06-13 12:58:28 | confirmed |
| 7       | 2021-06-14 13:59:27 | confirmed |
| 2       | 2021-01-22 00:00:00 | confirmed |
| 2       | 2021-02-28 23:59:59 | timeout   |
+---------+---------------------+-----------+
输出: 
+---------+-------------------+
| user_id | confirmation_rate |
+---------+-------------------+
| 6       | 0.00              |
| 3       | 0.00              |
| 7       | 1.00              |
| 2       | 0.50              |
+---------+-------------------+
解释:
用户 6 没有请求任何确认消息。确认率为 0。
用户 3 进行了 2 次请求，都超时了。确认率为 0。
用户 7 提出了 3 个请求，所有请求都得到了确认。确认率为 1。
用户 2 做了 2 个请求，其中一个被确认，另一个超时。确认率为 1 / 2 = 0.5。
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">WITH base AS (
  SELECT 
    user_id,
    COUNT(*) AS total,
    SUM(CASE WHEN action = &#39;confirmed&#39; THEN 1 ELSE 0 END) AS confirmed
  FROM Confirmations
  GROUP BY user_id
)
SELECT 
  s.user_id,
  ROUND(IFNULL(b.confirmed / b.total, 0), 2) AS confirmation_rate
FROM Signups s
LEFT JOIN base b
  ON s.user_id = b.user_id;
</code></pre>
<hr>
<h3 id="1193-每月交易I"><a href="#1193-每月交易I" class="headerlink" title="1193. 每月交易I"></a>1193. 每月交易I</h3><p>表：<code>Transactions</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| country       | varchar |
| state         | enum    |
| amount        | int     |
| trans_date    | date    |
+---------------+---------+
id 是这个表的主键。
该表包含有关传入事务的信息。
state 列类型为 [&quot;approved&quot;, &quot;declined&quot;] 之一。
</code></pre>
<p>编写一个 sql 查询来查找每个月和每个国家&#x2F;地区的事务数及其总金额、已批准的事务数及其总金额。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Transactions table:
+------+---------+----------+--------+------------+
| id   | country | state    | amount | trans_date |
+------+---------+----------+--------+------------+
| 121  | US      | approved | 1000   | 2018-12-18 |
| 122  | US      | declined | 2000   | 2018-12-19 |
| 123  | US      | approved | 2000   | 2019-01-01 |
| 124  | DE      | approved | 2000   | 2019-01-07 |
+------+---------+----------+--------+------------+
输出：
+----------+---------+-------------+----------------+--------------------+-----------------------+
| month    | country | trans_count | approved_count | trans_total_amount | approved_total_amount |
+----------+---------+-------------+----------------+--------------------+-----------------------+
| 2018-12  | US      | 2           | 1              | 3000               | 1000                  |
| 2019-01  | US      | 1           | 1              | 2000               | 2000                  |
| 2019-01  | DE      | 1           | 1              | 2000               | 2000                  |
+----------+---------+-------------+----------------+--------------------+-----------------------+
</code></pre>
<p>解答：</p>
<p>多个 CTE 用 <code>WITH a AS (...), b AS (...)</code>。</p>
<p>按 <code>month、country</code> 分组；<code>approved</code> 相关用 <code>CASE WHEN</code> 计数&#x2F;求和。</p>
<p>取月份用 <code>DATE_FORMAT(trans_date, &#39;%Y-%m&#39;)</code> 更稳妥。</p>
<p><strong>DATE_FORMAT(…, ‘%y-%m’)：结果是20-02，若是’%Y-%m，结果是2020-02，若是’%Y-%M，结果是2020-Febrary’</strong></p>
<pre><code class="language-sql">WITH base AS (
  SELECT
    DATE_FORMAT(trans_date, &#39;%Y-%m&#39;) AS month,
    country,
    state,
    amount
  FROM Transactions
),
seq AS (
  SELECT
    month,
    country,
    COUNT(*) AS trans_count,
    SUM(CASE WHEN state = &#39;approved&#39; THEN 1 ELSE 0 END) AS approved_count,
    SUM(amount) AS trans_total_amount,
    SUM(CASE WHEN state = &#39;approved&#39; THEN amount ELSE 0 END) AS approved_total_amount
  FROM base
  GROUP BY month, country
)
SELECT *
FROM seq;
</code></pre>
<hr>
<h3 id="1174-即时食物配送II"><a href="#1174-即时食物配送II" class="headerlink" title="1174. 即时食物配送II"></a>1174. 即时食物配送II</h3><p>配送表: <code>Delivery</code></p>
<pre><code>+-----------------------------+---------+
| Column Name                 | Type    |
+-----------------------------+---------+
| delivery_id                 | int     |
| customer_id                 | int     |
| order_date                  | date    |
| customer_pref_delivery_date | date    |
+-----------------------------+---------+
delivery_id 是该表中具有唯一值的列。
该表保存着顾客的食物配送信息，顾客在某个日期下了订单，并指定了一个期望的配送日期（和下单日期相同或者在那之后）。
</code></pre>
<p>如果顾客期望的配送日期和下单日期相同，则该订单称为 「<strong>即时订单</strong>」，否则称为「<strong>计划订单</strong>」。</p>
<p>「<strong>首次订单</strong>」是顾客最早创建的订单。我们保证一个顾客只会有一个「首次订单」。</p>
<p>编写解决方案以获取即时订单在所有用户的首次订单中的比例。<strong>保留两位小数。</strong></p>
<p>结果示例如下所示：</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Delivery 表：
+-------------+-------------+------------+-----------------------------+
| delivery_id | customer_id | order_date | customer_pref_delivery_date |
+-------------+-------------+------------+-----------------------------+
| 1           | 1           | 2019-08-01 | 2019-08-02                  |
| 2           | 2           | 2019-08-02 | 2019-08-02                  |
| 3           | 1           | 2019-08-11 | 2019-08-12                  |
| 4           | 3           | 2019-08-24 | 2019-08-24                  |
| 5           | 3           | 2019-08-21 | 2019-08-22                  |
| 6           | 2           | 2019-08-11 | 2019-08-13                  |
| 7           | 4           | 2019-08-09 | 2019-08-09                  |
+-------------+-------------+------------+-----------------------------+
输出：
+----------------------+
| immediate_percentage |
+----------------------+
| 50.00                |
+----------------------+
解释：
1 号顾客的 1 号订单是首次订单，并且是计划订单。
2 号顾客的 2 号订单是首次订单，并且是即时订单。
3 号顾客的 5 号订单是首次订单，并且是计划订单。
4 号顾客的 7 号订单是首次订单，并且是即时订单。
因此，一半顾客的首次订单是即时的。
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">with base as (
select *, row_number() over(partition by customer_id order by order_date) as rn 
from Delivery),
seq as (
    select round((sum(case when customer_pref_delivery_date = order_date then 1 else 0 end) / count(*)) * 100, 2) as immediate_percentage from base where rn = 1
)
select * from seq;
</code></pre>
<hr>
<h3 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a>176. 第二高的薪水</h3><p><code>Employee</code> 表：</p>
<pre><code>+-------------+------+
| Column Name | Type |
+-------------+------+
| id          | int  |
| salary      | int  |
+-------------+------+
id 是这个表的主键。
表的每一行包含员工的工资信息。
</code></pre>
<p>查询并返回 <code>Employee</code> 表中第二高的 <strong>不同</strong> 薪水 。如果不存在第二高的薪水，查询应该返回 <code>null(Pandas 则返回 None)</code> 。</p>
<p>查询结果如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Employee 表：
+----+--------+
| id | salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
输出：
+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：
Employee 表：
+----+--------+
| id | salary |
+----+--------+
| 1  | 100    |
+----+--------+
输出：
+---------------------+
| SecondHighestSalary |
+---------------------+
| null                |
+---------------------+
</code></pre>
<p>解答</p>
<pre><code class="language-sql">SELECT MAX(salary) AS SecondHighestSalary
FROM (
  SELECT DISTINCT salary,
         DENSE_RANK() OVER (ORDER BY salary DESC) AS rk
  FROM Employee
) t
WHERE rk = 2;
</code></pre>
<h4 id="（1）-子查询为空但外层用了聚合函数"><a href="#（1）-子查询为空但外层用了聚合函数" class="headerlink" title="（1） 子查询为空但外层用了聚合函数"></a>（1） 子查询为空但外层用了聚合函数</h4><p>SQL 的定义是：聚合函数对空输入时，返回 <strong>NULL</strong>。<br> 例子：</p>
<pre><code class="language-sql">SELECT MAX(salary) FROM (SELECT 1 AS salary WHERE 1=0) t;
</code></pre>
<p><code>(SELECT 1 WHERE 1=0)</code> 为空表 → <code>MAX</code> 没有任何值可比较 → 返回 <code>NULL</code>。</p>
<p>所以这就是为什么“第二高薪水不存在”时 <code>MAX</code> 可以帮我们自动返回 <code>NULL</code>。</p>
<hr>
<h4 id="（2）子查询为空而外层没有聚合函数"><a href="#（2）子查询为空而外层没有聚合函数" class="headerlink" title="（2）子查询为空而外层没有聚合函数"></a>（2）子查询为空而外层没有聚合函数</h4><p>如果你直接：</p>
<pre><code class="language-sql">SELECT salary 
FROM (SELECT salary WHERE 1=0) t;
</code></pre>
<p>那结果就是 <strong>0 行</strong>（即直接返回空结果集，不会自动给你一行 <code>NULL</code>）。</p>
<hr>
<h3 id="550-游戏玩法分析IV"><a href="#550-游戏玩法分析IV" class="headerlink" title="550. 游戏玩法分析IV"></a>550. 游戏玩法分析IV</h3><p>Table: <code>Activity</code></p>
<pre><code>+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
（player_id，event_date）是此表的主键（具有唯一值的列的组合）。
这张表显示了某些游戏的玩家的活动情况。
每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0）。
</code></pre>
<p>编写解决方案，报告在首次登录的第二天再次登录的玩家的 <strong>比率</strong>，<strong>四舍五入到小数点后两位</strong>。换句话说，你需要计算从首次登录后的第二天登录的玩家数量，并将其除以总玩家数。</p>
<p>结果格式如下所示：</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-03-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+
输出：
+-----------+
| fraction  |
+-----------+
| 0.33      |
+-----------+
解释：
只有 ID 为 1 的玩家在第一天登录后才重新登录，所以答案是 1/3 = 0.33
</code></pre>
<p>解答：</p>
<pre><code class="language-sql"># Write your MySQL query statement below
with base as(
    select *,min(event_date) over(partition by player_id)as first from Activity
),
seq as(
    select player_id, sum(case when datediff(event_date, first) = 1 then 1 else 0 end) as rn from base
    group by player_id
)
select round(IFNULL((sum(rn) / count(distinct player_id)), 0), 2) as fraction from seq;
</code></pre>
<p>注意：</p>
<ol>
<li>在使用with base as(), seq as() select from seq时，要记得每个嵌套内部的select很重要，前一个select需要包含后一个select的内容。</li>
<li>使用聚合函数min,max,count后结果会被压缩，如果后续要同行对最大、最小进行比较，要使用窗口函数形式的max,min…</li>
</ol>
<hr>
<h3 id="1045-买下所有产品的客户"><a href="#1045-买下所有产品的客户" class="headerlink" title="1045. 买下所有产品的客户"></a>1045. 买下所有产品的客户</h3><p><code>Customer</code> 表：</p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| customer_id | int     |
| product_key | int     |
+-------------+---------+
该表可能包含重复的行。
customer_id 不为 NULL。
product_key 是 Product 表的外键(reference 列)。
</code></pre>
<p><code>Product</code> 表：</p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| product_key | int     |
+-------------+---------+
product_key 是这张表的主键（具有唯一值的列）。
</code></pre>
<p>编写解决方案，报告 <code>Customer</code> 表中购买了 <code>Product</code> 表中所有产品的客户的 id。</p>
<p>返回结果表 <strong>无顺序要求</strong> 。</p>
<p>返回结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Customer 表：
+-------------+-------------+
| customer_id | product_key |
+-------------+-------------+
| 1           | 5           |
| 2           | 6           |
| 3           | 5           |
| 3           | 6           |
| 1           | 6           |
+-------------+-------------+
Product 表：
+-------------+
| product_key |
+-------------+
| 5           |
| 6           |
+-------------+
输出：
+-------------+
| customer_id |
+-------------+
| 1           |
| 3           |
+-------------+
解释：
购买了所有产品（5 和 6）的客户的 id 是 1 和 3 。
</code></pre>
<p>解答：</p>
<ol>
<li><strong><code>WHERE DISTINCT</code> 是非法语法</strong>。<code>DISTINCT</code> 只能放在 <code>SELECT</code> 或 <code>COUNT(DISTINCT ...)</code> 里面，不能直接放在 <code>WHERE</code>。</li>
<li>题目要求的是“买了所有产品的顾客”，所以应该比较顾客买到的 <strong>去重后产品数</strong> 和 <strong>Product 表里的产品总数</strong>。</li>
</ol>
<pre><code class="language-sql">SELECT customer_id
FROM Customer
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (
    SELECT COUNT(*) FROM Product
);
</code></pre>
<p>解释一下：</p>
<ul>
<li><code>GROUP BY customer_id</code>：按顾客分组。</li>
<li><code>COUNT(DISTINCT product_key)</code>：统计该顾客买了多少种不同的产品。</li>
<li>子查询 <code>(SELECT COUNT(*) FROM Product)</code>：统计总共有多少种产品。</li>
<li><code>HAVING ... = ...</code>：筛选出买全所有产品的顾客。</li>
</ul>
<hr>
<h3 id="180-连续出现的数字"><a href="#180-连续出现的数字" class="headerlink" title="180. 连续出现的数字"></a>180. 连续出现的数字</h3><p>表：<code>Logs</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| num         | varchar |
+-------------+---------+
在 SQL 中，id 是该表的主键。
id 是一个自增列。
</code></pre>
<p>找出所有至少连续出现三次的数字。</p>
<p>返回的结果表中的数据可以按 <strong>任意顺序</strong> 排列。</p>
<p>结果格式如下面的例子所示：</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Logs 表：
+----+-----+
| id | num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+
输出：
Result 表：
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
解释：1 是唯一连续出现至少三次的数字。
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">with base as(
    select *, row_number() over(partition by num order by id) as rn from Logs
),
seq as(
    select *, id - rn as diff from base 
),
rpq as (
    select num, count(*) as ct from seq group by num, diff having count(*) &gt;= 3
)
select distinct num as ConsecutiveNums from rpq;
</code></pre>
<p><strong>有时候不要忘记distinct</strong></p>
<hr>
<h3 id="1164-指定日期的产品价格"><a href="#1164-指定日期的产品价格" class="headerlink" title="1164. 指定日期的产品价格"></a>1164. 指定日期的产品价格</h3><p>产品数据表: <code>Products</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| new_price     | int     |
| change_date   | date    |
+---------------+---------+
(product_id, change_date) 是此表的主键（具有唯一值的列组合）。
这张表的每一行分别记录了 某产品 在某个日期 更改后 的新价格。
</code></pre>
<p>一开始，所有产品价格都为 10。</p>
<p>编写一个解决方案，找出在 <code>2019-08-16</code> 所有产品的价格。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>结果格式如下例所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Products 表:
+------------+-----------+-------------+
| product_id | new_price | change_date |
+------------+-----------+-------------+
| 1          | 20        | 2019-08-14  |
| 2          | 50        | 2019-08-14  |
| 1          | 30        | 2019-08-15  |
| 1          | 35        | 2019-08-16  |
| 2          | 65        | 2019-08-17  |
| 3          | 20        | 2019-08-18  |
+------------+-----------+-------------+
输出：
+------------+-------+
| product_id | price |
+------------+-------+
| 2          | 50    |
| 1          | 35    |
| 3          | 10    |
+------------+-------+
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">with base as(
    select *, row_number()over (partition by product_id order by change_date DESC) as rn from Products where change_date &lt;= &#39;2019-08-16&#39;
),
seq as (
    select product_id, new_price as price from base where rn = 1
)
select product_id, price from seq union all select distinct product_id, 10 as price from (
    select product_id, min(change_date) as mi from Products group by product_id
)t  where mi &gt; &#39;2019-08-16&#39;;
</code></pre>
<p>归纳：<br>想要得到某一列的最大最小值，并用其与某个数进行比较，需要先max、min（窗口或者聚合函数），然后再等值查询，或者rownumber配合ASC、DESC，然后再后续查询中使用rn&#x3D;1，或者直接使用order by+limit</p>
<h4 id="（1）非相关子查询-等值比较"><a href="#（1）非相关子查询-等值比较" class="headerlink" title="（1）非相关子查询 + 等值比较"></a>（1）非相关子查询 + 等值比较</h4><p><strong>使用场景</strong>：<strong>全局只有一个最值</strong>（整个表的最大值&#x2F;最小值），不依赖分组。</p>
<ul>
<li>特点：子查询返回单行，可以直接用 <code>=</code> 比较。</li>
<li>示例：找出工资最高的员工</li>
</ul>
<pre><code class="language-sql">select *
from Employee
where salary = (select max(salary) from Employee);
</code></pre>
<hr>
<h4 id="（2）相关子查询"><a href="#（2）相关子查询" class="headerlink" title="（2）相关子查询"></a>（2）相关子查询</h4><p><strong>使用场景</strong>：<strong>分组后的最值</strong>（每个客户&#x2F;部门的最小&#x2F;最大日期），外层表的条件依赖子查询。</p>
<ul>
<li>特点：子查询里需要引用外层的列，每行执行一次，保证返回单行。</li>
<li>示例：找每个客户的首单</li>
</ul>
<pre><code class="language-sql">select *
from Delivery d1
where order_date = (
  select min(order_date)
  from Delivery d2
  where d2.customer_id = d1.customer_id
);
</code></pre>
<p>这里子查询里的 <code>d2.customer_id = d1.customer_id</code> 绑定了外层查询的 <code>d1.customer_id</code>。</p>
<p>每次外层取一行，子查询就只计算该客户的最小订单日期。</p>
<p>也可以写成这种形式：</p>
<pre><code class="language-sql">select *
from (
  select customer_id, min(order_date)
  from Delivery 
  group by customer_id
)t ;
</code></pre>
<hr>
<h4 id="（3）窗口函数-条件筛选"><a href="#（3）窗口函数-条件筛选" class="headerlink" title="（3）窗口函数 + 条件筛选"></a>（3）窗口函数 + 条件筛选</h4><p><strong>使用场景</strong>：数据库支持窗口函数（MySQL 8+ &#x2F; PostgreSQL &#x2F; Oracle &#x2F; SQL Server），<strong>需要按组取前几名&#x2F;最值。</strong></p>
<p>也可以使用max、min的窗口函数形式来获取每个组别的最值</p>
<ul>
<li>特点：写法简洁，可同时保留分组内排序信息。</li>
<li>示例：找每个客户的首单</li>
</ul>
<pre><code class="language-sql">with t as (
  select *,
         row_number() over(partition by customer_id order by order_date) as rn
  from Delivery
)
select *
from t
where rn = 1;
</code></pre>
<ul>
<li>如果要处理并列情况，可以用 <code>rank()</code> 或 <code>dense_rank()</code>。</li>
</ul>
<hr>
<h4 id="（4）ORDER-BY-LIMIT"><a href="#（4）ORDER-BY-LIMIT" class="headerlink" title="（4）ORDER BY + LIMIT"></a>（4）ORDER BY + LIMIT</h4><p><strong>使用场景</strong>：<strong>只需要全表范围内的最值</strong>，且只取前 N 条（不分组）。</p>
<ul>
<li>特点：简单高效，但无法直接应对「每组最值」问题。</li>
<li>示例：找工资最高的员工（Top 1）</li>
</ul>
<pre><code class="language-sql">select *
from Employee
order by salary desc
limit 1;
</code></pre>
<ul>
<li>如果需要每组最值，就不适合，只能配合窗口函数或子查询。</li>
</ul>
<hr>
<h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><table>
<thead>
<tr>
<th>方法</th>
<th>适用场景</th>
<th>优点</th>
<th>局限</th>
</tr>
</thead>
<tbody><tr>
<td><strong>非相关子查询</strong></td>
<td>全表唯一最值</td>
<td>简单</td>
<td>只能处理单个全局最值</td>
</tr>
<tr>
<td><strong>相关子查询</strong></td>
<td>每组最值（需要依赖外层条件）</td>
<td>通用，不要求窗口函数</td>
<td>子查询多次执行，性能较差</td>
</tr>
<tr>
<td><strong>窗口函数</strong></td>
<td>每组最值&#x2F;前 N 个</td>
<td>高效简洁，现代 SQL 推荐</td>
<td>需要数据库支持窗口函数</td>
</tr>
<tr>
<td><strong>ORDER BY + LIMIT</strong></td>
<td>全表前 N 个</td>
<td>简洁高效</td>
<td>不能分组，只能处理全局最值</td>
</tr>
</tbody></table>
<hr>
<p>👉 快速记忆：</p>
<ul>
<li><strong>全局最值</strong> → 非相关子查询 或 <code>order by + limit</code></li>
<li><strong>分组最值</strong> → 相关子查询 或 窗口函数</li>
<li><strong>要前 N 名&#x2F;并列情况</strong> → 窗口函数最佳</li>
</ul>
<hr>
<h3 id="1204-最后一个能进入巴士的人"><a href="#1204-最后一个能进入巴士的人" class="headerlink" title="1204.最后一个能进入巴士的人"></a>1204.最后一个能进入巴士的人</h3><p>表: <code>Queue</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| person_id   | int     |
| person_name | varchar |
| weight      | int     |
| turn        | int     |
+-------------+---------+
person_id 是这个表具有唯一值的列。
该表展示了所有候车乘客的信息。
表中 person_id 和 turn 列将包含从 1 到 n 的所有数字，其中 n 是表中的行数。
turn 决定了候车乘客上巴士的顺序，其中 turn=1 表示第一个上巴士，turn=n 表示最后一个上巴士。
weight 表示候车乘客的体重，以千克为单位。
</code></pre>
<p>有一队乘客在等着上巴士。然而，巴士有<code>1000</code> <strong>千克</strong> 的重量限制，所以其中一部分乘客可能无法上巴士。</p>
<p>编写解决方案找出 <strong>最后一个</strong> 上巴士且不超过重量限制的乘客，并报告 <code>person_name</code> 。题目测试用例确保顺位第一的人可以上巴士且不会超重。</p>
<p>返回结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Queue 表
+-----------+-------------+--------+------+
| person_id | person_name | weight | turn |
+-----------+-------------+--------+------+
| 5         | Alice       | 250    | 1    |
| 4         | Bob         | 175    | 5    |
| 3         | Alex        | 350    | 2    |
| 6         | John Cena   | 400    | 3    |
| 1         | Winston     | 500    | 6    |
| 2         | Marie       | 200    | 4    |
+-----------+-------------+--------+------+
输出：
+-------------+
| person_name |
+-------------+
| John Cena   |
+-------------+
解释：
为了简化，Queue 表按 turn 列由小到大排序。
+------+----+-----------+--------+--------------+
| Turn | ID | Name      | Weight | Total Weight |
+------+----+-----------+--------+--------------+
| 1    | 5  | Alice     | 250    | 250          |
| 2    | 3  | Alex      | 350    | 600          |
| 3    | 6  | John Cena | 400    | 1000         | (最后一个上巴士)
| 4    | 2  | Marie     | 200    | 1200         | (无法上巴士)
| 5    | 4  | Bob       | 175    | ___          |
| 6    | 1  | Winston   | 500    | ___          |
+------+----+-----------+--------+--------------+
</code></pre>
<p>解答：</p>
<p><strong>PS：SQL 聚合函数（如 <code>MAX()</code>）和普通列之间没有自动的“行对齐”关系。</strong></p>
<p>不能直接写成！：</p>
<pre><code class="language-sql">select person_name, max(total_weight) from (
    select * , sum(weight)over (order by turn) as total_weight from Queue
)t where total_weight &lt;= 1000;

-- 结果只会返回
| person_id | person_name | weight | turn |
| --------- | ----------- | ------ | ---- |
| 5         | Alice       | 250    | 1    |
| 4         | Bob         | 175    | 5    |
| 3         | Alex        | 350    | 2    |
| 6         | John Cena   | 400    | 3    |
| 1         | Winston     | 500    | 6    |
| 2         | Marie       | 200    | 4    |

| person_name | max(total_weight) |
| ----------- | ----------------- |
| Alice       | 1000              |

-- 而不是正确输出
| person_name |
| ----------- |
| John Cena   |
</code></pre>
<h4 id="（1）子查询-等值过滤"><a href="#（1）子查询-等值过滤" class="headerlink" title="（1）子查询+等值过滤"></a>（1）子查询+等值过滤</h4><pre><code class="language-sql"># Write your MySQL query statement below
with base as(
    select * , sum(weight)over (order by turn) as total_weight from Queue
)
select person_name from base where total_weight = (
    select max(total_weight) as mx from base where total_weight &lt;= 1000
);
</code></pre>
<hr>
<h4 id="（2）ORDER-BY-LIMIT"><a href="#（2）ORDER-BY-LIMIT" class="headerlink" title="（2）ORDER BY+LIMIT"></a>（2）ORDER BY+LIMIT</h4><pre><code class="language-sql"># Write your MySQL query statement below
select person_name from (
    select * , sum(weight)over (order by turn) as total_weight from Queue
)t where total_weight &lt;= 1000 order by total_weight DESC limit 1;
</code></pre>
<hr>
<h3 id="1907-按分类统计薪水"><a href="#1907-按分类统计薪水" class="headerlink" title="1907. 按分类统计薪水"></a>1907. 按分类统计薪水</h3><p>表: <code>Accounts</code></p>
<pre><code>+-------------+------+
| 列名        | 类型  |
+-------------+------+
| account_id  | int  |
| income      | int  |
+-------------+------+
在 SQL 中，account_id 是这个表的主键。
每一行都包含一个银行帐户的月收入的信息。
</code></pre>
<p>查询每个工资类别的银行账户数量。 工资类别如下：</p>
<ul>
<li><code>&quot;Low Salary&quot;</code>：所有工资 <strong>严格低于</strong> <code>20000</code> 美元。</li>
<li><code>&quot;Average Salary&quot;</code>： <strong>包含</strong> 范围内的所有工资 <code>[$20000, $50000]</code> 。</li>
<li><code>&quot;High Salary&quot;</code>：所有工资 <strong>严格大于</strong> <code>50000</code> 美元。</li>
</ul>
<p>结果表 <strong>必须</strong> 包含所有三个类别。 如果某个类别中没有帐户，则报告 <code>0</code> 。</p>
<p>按 <strong>任意顺序</strong> 返回结果表。</p>
<p>查询结果格式如下示例。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Accounts 表:
+------------+--------+
| account_id | income |
+------------+--------+
| 3          | 108939 |
| 2          | 12747  |
| 8          | 87709  |
| 6          | 91796  |
+------------+--------+
输出：
+----------------+----------------+
| category       | accounts_count |
+----------------+----------------+
| Low Salary     | 1              |
| Average Salary | 0              |
| High Salary    | 3              |
+----------------+----------------+
解释：
低薪: 有一个账户 2.
中等薪水: 没有.
高薪: 有三个账户，他们是 3, 6和 8.
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">select &#39;Low Salary&#39; as category, sum(case when income &lt; 20000 then 1 else 0 end) as accounts_count
from Accounts
Union all
select &#39;Average Salary&#39; as category, sum(case when income &gt;= 20000 and income &lt;= 50000 then 1 else 0 end) as accounts_count
from Accounts
Union all
select &#39;High Salary&#39; as category, sum(case when income &gt; 50000 then 1 else 0 end) as accounts_count
from Accounts;
</code></pre>
<hr>
<h3 id="626-换座位"><a href="#626-换座位" class="headerlink" title="626. 换座位"></a>626. 换座位</h3><p>表: <code>Seat</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| student     | varchar |
+-------------+---------+
id 是该表的主键（唯一值）列。
该表的每一行都表示学生的姓名和 ID。
ID 序列始终从 1 开始并连续增加。
</code></pre>
<p>编写解决方案来交换每两个连续的学生的座位号。如果学生的数量是奇数，则最后一个学生的id不交换。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 
Seat 表:
+----+---------+
| id | student |
+----+---------+
| 1  | Abbot   |
| 2  | Doris   |
| 3  | Emerson |
| 4  | Green   |
| 5  | Jeames  |
+----+---------+
输出: 
+----+---------+
| id | student |
+----+---------+
| 1  | Doris   |
| 2  | Abbot   |
| 3  | Green   |
| 4  | Emerson |
| 5  | Jeames  |
+----+---------+
解释:
请注意，如果学生人数为奇数，则不需要更换最后一名学生的座位。
</code></pre>
<p>解答：</p>
<h4 id="（1）嵌套查询"><a href="#（1）嵌套查询" class="headerlink" title="（1）嵌套查询"></a>（1）嵌套查询</h4><pre><code class="language-sql"># Write your MySQL query statement below
with base as(
    select *, lead(student, 1)over (order by id) as exchange_nxt, lag(student, 1)over (order by id) as exchange_pre from Seat
)
select id, IFNULL((case when (id % 2) != 0 then exchange_nxt else exchange_pre end), student) as student from base;
</code></pre>
<h4 id="（2）CASE-WHEN"><a href="#（2）CASE-WHEN" class="headerlink" title="（2）CASE WHEN"></a>（2）CASE WHEN</h4><pre><code class="language-sql"># Write your MySQL query statement below
select case 
        when id % 2 = 1 and id &lt; (select max(id) from Seat)
            then id + 1
        when id % 2 = 0 
            then id - 1
        else id
        end as id, student
    from Seat
order by id;
</code></pre>
<p>在 SQL 里，<code>CASE</code> 可以写两种形式：</p>
<h5 id="a-简单-CASE"><a href="#a-简单-CASE" class="headerlink" title="a. 简单 CASE"></a>a. 简单 CASE</h5><p>直接对某个表达式的值做匹配：</p>
<pre><code class="language-sql">CASE column_name
    WHEN &#39;A&#39; THEN &#39;类型1&#39;
    WHEN &#39;B&#39; THEN &#39;类型2&#39;
    ELSE &#39;其他&#39;
END
</code></pre>
<h5 id="b-搜索-CASE-（最常用）"><a href="#b-搜索-CASE-（最常用）" class="headerlink" title="b. 搜索 CASE （最常用）"></a>b. 搜索 CASE （最常用）</h5><p>条件判断灵活，可以写比较、范围等：</p>
<pre><code class="language-sql">CASE
    WHEN score &gt;= 90 THEN &#39;优秀&#39;
    WHEN score &gt;= 60 THEN &#39;及格&#39;
    ELSE &#39;不及格&#39;
END
</code></pre>
<h5 id="c-作为一个字段输出"><a href="#c-作为一个字段输出" class="headerlink" title="c. 作为一个字段输出"></a>c. 作为一个字段输出</h5><pre><code class="language-sql">SELECT name,
       CASE WHEN age &lt; 18 THEN &#39;未成年&#39;
            WHEN age &lt; 60 THEN &#39;成年人&#39;
            ELSE &#39;老年人&#39;
       END AS age_group
FROM users;
</code></pre>
<h5 id="d-在聚合函数里做条件统计"><a href="#d-在聚合函数里做条件统计" class="headerlink" title="d. 在聚合函数里做条件统计"></a>d. 在聚合函数里做条件统计</h5><pre><code class="language-sql">SELECT
    SUM(CASE WHEN status = &#39;success&#39; THEN 1 ELSE 0 END) AS success_count,
    SUM(CASE WHEN status = &#39;fail&#39; THEN 1 ELSE 0 END)    AS fail_count
FROM logs;
</code></pre>
<p>常用于 <strong>条件计数</strong>。</p>
<h5 id="e-排序（ORDER-BY）"><a href="#e-排序（ORDER-BY）" class="headerlink" title="e. 排序（ORDER BY）"></a>e. 排序（ORDER BY）</h5><pre><code class="language-sql">SELECT *
FROM orders
ORDER BY
  CASE 
    WHEN status = &#39;vip&#39; THEN 1
    WHEN status = &#39;normal&#39; THEN 2
    ELSE 3
  END;
</code></pre>
<hr>
<h3 id="1341-电影评分"><a href="#1341-电影评分" class="headerlink" title="1341. 电影评分"></a>1341. 电影评分</h3><p>表：<code>Movies</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| movie_id      | int     |
| title         | varchar |
+---------------+---------+
movie_id 是这个表的主键(具有唯一值的列)。
title 是电影的名字。
</code></pre>
<p>表：<code>Users</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user_id       | int     |
| name          | varchar |
+---------------+---------+
user_id 是表的主键(具有唯一值的列)。
&#39;name&#39; 列具有唯一值。
</code></pre>
<p>表：<code>MovieRating</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| movie_id      | int     |
| user_id       | int     |
| rating        | int     |
| created_at    | date    |
+---------------+---------+
(movie_id, user_id) 是这个表的主键(具有唯一值的列的组合)。
这个表包含用户在其评论中对电影的评分 rating 。
created_at 是用户的点评日期。 
</code></pre>
<p>请你编写一个解决方案：</p>
<ul>
<li>查找评论电影数量最多的用户名。如果出现平局，返回字典序较小的用户名。</li>
<li>查找在 <code>February 2020</code> <strong>平均评分最高</strong> 的电影名称。如果出现平局，返回字典序较小的电影名称。</li>
</ul>
<p><strong>字典序</strong> ，即按字母在字典中出现顺序对字符串排序，字典序较小则意味着排序靠前。</p>
<p>返回结果格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Movies 表：
+-------------+--------------+
| movie_id    |  title       |
+-------------+--------------+
| 1           | Avengers     |
| 2           | Frozen 2     |
| 3           | Joker        |
+-------------+--------------+
Users 表：
+-------------+--------------+
| user_id     |  name        |
+-------------+--------------+
| 1           | Daniel       |
| 2           | Monica       |
| 3           | Maria        |
| 4           | James        |
+-------------+--------------+
MovieRating 表：
+-------------+--------------+--------------+-------------+
| movie_id    | user_id      | rating       | created_at  |
+-------------+--------------+--------------+-------------+
| 1           | 1            | 3            | 2020-01-12  |
| 1           | 2            | 4            | 2020-02-11  |
| 1           | 3            | 2            | 2020-02-12  |
| 1           | 4            | 1            | 2020-01-01  |
| 2           | 1            | 5            | 2020-02-17  | 
| 2           | 2            | 2            | 2020-02-01  | 
| 2           | 3            | 2            | 2020-03-01  |
| 3           | 1            | 3            | 2020-02-22  | 
| 3           | 2            | 4            | 2020-02-25  | 
+-------------+--------------+--------------+-------------+
输出：
Result 表：
+--------------+
| results      |
+--------------+
| Daniel       |
| Frozen 2     |
+--------------+
解释：
Daniel 和 Monica 都点评了 3 部电影（&quot;Avengers&quot;, &quot;Frozen 2&quot; 和 &quot;Joker&quot;） 但是 Daniel 字典序比较小。
Frozen 2 和 Joker 在 2 月的评分都是 3.5，但是 Frozen 2 的字典序比较小。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">with base as(
    select *, avg(rating) as avg_rate from (
        select *, date_format(created_at, &#39;%Y-%m&#39;) as created_month from MovieRating 
        where date_format(created_at, &#39;%Y-%m&#39;) = &#39;2020-02&#39;
    )a group by movie_id
),
seq as (
    select movie_id from base where avg_rate = (
        select max(avg_rate) from base 
    )
),
base2 as(
    select s.user_id from(
        select t.user_id, rank() over(order by ct DESC) as rk from(
            select user_id, count(*) as ct from  MovieRating group by user_id
        )t
    )s where s.rk = 1
)
select min(a.name) as results from Users a join base2 b on a.user_id = b.user_id union all
    select min(a.title) as results from Movies a join seq b on a.movie_id = b.movie_id;
</code></pre>
<p><strong>PS:</strong></p>
<p>（1）如果需要获取某一列中不同值的总数，eg:id列1,2,3出现的次数，可以</p>
<pre><code class="language-sql">select count(*) from emp group by id
</code></pre>
<p>（2）等值子查询只能返回一个结果，子查询里select的数值不能超过一行</p>
<hr>
<h3 id="1321-餐厅营业额变化增长"><a href="#1321-餐厅营业额变化增长" class="headerlink" title="1321. 餐厅营业额变化增长"></a>1321. 餐厅营业额变化增长</h3><p>表: <code>Customer</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| customer_id   | int     |
| name          | varchar |
| visited_on    | date    |
| amount        | int     |
+---------------+---------+
在 SQL 中，(customer_id, visited_on) 是该表的主键。
该表包含一家餐馆的顾客交易数据。
visited_on 表示 (customer_id) 的顾客在 visited_on 那天访问了餐馆。
amount 是一个顾客某一天的消费总额。
</code></pre>
<p>你是餐馆的老板，现在你想分析一下可能的营业额变化增长（每天至少有一位顾客）。</p>
<p>计算以 7 天（某日期 + 该日期前的 6 天）为一个时间段的顾客消费平均值。<code>average_amount</code> 要 <strong>保留两位小数。</strong></p>
<p>结果按 <code>visited_on</code> <strong>升序排序</strong>。</p>
<p>返回结果格式的例子如下。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Customer 表:
+-------------+--------------+--------------+-------------+
| customer_id | name         | visited_on   | amount      |
+-------------+--------------+--------------+-------------+
| 1           | Jhon         | 2019-01-01   | 100         |
| 2           | Daniel       | 2019-01-02   | 110         |
| 3           | Jade         | 2019-01-03   | 120         |
| 4           | Khaled       | 2019-01-04   | 130         |
| 5           | Winston      | 2019-01-05   | 110         | 
| 6           | Elvis        | 2019-01-06   | 140         | 
| 7           | Anna         | 2019-01-07   | 150         |
| 8           | Maria        | 2019-01-08   | 80          |
| 9           | Jaze         | 2019-01-09   | 110         | 
| 1           | Jhon         | 2019-01-10   | 130         | 
| 3           | Jade         | 2019-01-10   | 150         | 
+-------------+--------------+--------------+-------------+
输出：
+--------------+--------------+----------------+
| visited_on   | amount       | average_amount |
+--------------+--------------+----------------+
| 2019-01-07   | 860          | 122.86         |
| 2019-01-08   | 840          | 120            |
| 2019-01-09   | 840          | 120            |
| 2019-01-10   | 1000         | 142.86         |
+--------------+--------------+----------------+
解释：
第一个七天消费平均值从 2019-01-01 到 2019-01-07 是restaurant-growth/restaurant-growth/ (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.86
第二个七天消费平均值从 2019-01-02 到 2019-01-08 是 (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 120
第三个七天消费平均值从 2019-01-03 到 2019-01-09 是 (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 120
第四个七天消费平均值从 2019-01-04 到 2019-01-10 是 (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">select visited_on, total_amount as amount, round(total_amount / 7, 2) as average_amount from( 
    select visited_on, sum(new_amount)over (order by visited_on ROWS 6 PRECEDING) total_amount from (
        select visited_on, sum(amount) new_amount from Customer group by visited_on
    )s
)t where visited_on &gt;= (
    select min(visited_on) + 6 from Customer
);
</code></pre>
<p>窗口函数可以选择操作数据的范围</p>
<p>eg：</p>
<pre><code class="language-sql">取当前行和前五行：ROWS between 5 preceding and current row --共6行
取当前行和后五行：ROWS between current row and 5 following --共6行
取前五行和后五行：ROWS between 5 preceding and 5 folowing --共11行
</code></pre>
<hr>
<h3 id="602-好友申请ll：谁有最多的好友"><a href="#602-好友申请ll：谁有最多的好友" class="headerlink" title="602.好友申请ll：谁有最多的好友"></a>602.好友申请ll：谁有最多的好友</h3><p><code>RequestAccepted</code> 表：</p>
<pre><code>+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| requester_id   | int     |
| accepter_id    | int     |
| accept_date    | date    |
+----------------+---------+
(requester_id, accepter_id) 是这张表的主键(具有唯一值的列的组合)。
这张表包含发送好友请求的人的 ID ，接收好友请求的人的 ID ，以及好友请求通过的日期。
</code></pre>
<p>编写解决方案，找出拥有最多的好友的人和他拥有的好友数目。</p>
<p>生成的测试用例保证拥有最多好友数目的只有 1 个人。</p>
<p>查询结果格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
RequestAccepted 表：
+--------------+-------------+-------------+
| requester_id | accepter_id | accept_date |
+--------------+-------------+-------------+
| 1            | 2           | 2016/06/03  |
| 1            | 3           | 2016/06/08  |
| 2            | 3           | 2016/06/08  |
| 3            | 4           | 2016/06/09  |
+--------------+-------------+-------------+
输出：
+----+-----+
| id | num |
+----+-----+
| 3  | 3   |
+----+-----+
解释：
编号为 3 的人是编号为 1 ，2 和 4 的人的好友，所以他总共有 3 个好友，比其他人都多。
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">with base as (
    select accepter_id, count(*) as accepted_num 
    from RequestAccepted 
    group by accepter_id
),
seq as (
    select requester_id, count(*) as requested_num 
    from RequestAccepted 
    group by requester_id
),
seq1 as (
    -- 左连接
    select a.accepter_id as id, 
           ifnull(a.accepted_num,0) + ifnull(b.requested_num,0) as num
    from base a 
    left join seq b on a.accepter_id = b.requester_id
    
    union
    
    -- 右连接（补齐右边独有的行）
    select b.requester_id as id, 
           ifnull(a.accepted_num,0) + ifnull(b.requested_num,0) as num
    from base a 
    right join seq b on a.accepter_id = b.requester_id
)
select id, num
from seq1
where num = (select max(num) from seq1);
</code></pre>
<ul>
<li><code>union</code> 保证把两边独有的 id 都保留下来，等价于 FULL OUTER JOIN。</li>
<li><code>ifnull(...,0)</code> 是避免 NULL 相加导致结果为 NULL。</li>
<li>最后取最大值即可。</li>
</ul>
<hr>
<h3 id="585-2016年的投资"><a href="#585-2016年的投资" class="headerlink" title="585.2016年的投资"></a>585.2016年的投资</h3><p><code>Insurance</code> 表：</p>
<pre><code>+-------------+-------+
| Column Name | Type  |
+-------------+-------+
| pid         | int   |
| tiv_2015    | float |
| tiv_2016    | float |
| lat         | float |
| lon         | float |
+-------------+-------+
pid 是这张表的主键(具有唯一值的列)。
表中的每一行都包含一条保险信息，其中：
pid 是投保人的投保编号。
tiv_2015 是该投保人在 2015 年的总投保金额，tiv_2016 是该投保人在 2016 年的总投保金额。
lat 是投保人所在城市的纬度。题目数据确保 lat 不为空。
lon 是投保人所在城市的经度。题目数据确保 lon 不为空。
</code></pre>
<p>编写解决方案报告 2016 年 (<code>tiv_2016</code>) 所有满足下述条件的投保人的投保金额之和：</p>
<ul>
<li>他在 2015 年的投保额 (<code>tiv_2015</code>) 至少跟一个其他投保人在 2015 年的投保额相同。</li>
<li>他所在的城市必须与其他投保人都不同（也就是说 (<code>lat, lon</code>) 不能跟其他任何一个投保人完全相同）。</li>
</ul>
<p><code>tiv_2016</code> 四舍五入的 <strong>两位小数</strong> 。</p>
<p>查询结果格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Insurance 表：
+-----+----------+----------+-----+-----+
| pid | tiv_2015 | tiv_2016 | lat | lon |
+-----+----------+----------+-----+-----+
| 1   | 10       | 5        | 10  | 10  |
| 2   | 20       | 20       | 20  | 20  |
| 3   | 10       | 30       | 20  | 20  |
| 4   | 10       | 40       | 40  | 40  |
+-----+----------+----------+-----+-----+
输出：
+----------+
| tiv_2016 |
+----------+
| 45.00    |
+----------+
解释：
表中的第一条记录和最后一条记录都满足两个条件。
tiv_2015 值为 10 与第三条和第四条记录相同，且其位置是唯一的。

第二条记录不符合任何一个条件。其 tiv_2015 与其他投保人不同，并且位置与第三条记录相同，这也导致了第三条记录不符合题目要求。
因此，结果是第一条记录和最后一条记录的 tiv_2016 之和，即 45 。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select round(sum(tiv_2016), 2) as tiv_2016 from (
    select a.pid, a.tiv_2016 from Insurance a where a.tiv_2015 in (
        select b.tiv_2015 from Insurance b where a.pid &lt;&gt; b.pid
    ) and not exists (
        select 1 
        from Insurance b 
        where a.pid &lt;&gt; b.pid 
        and a.lat = b.lat 
        and a.lon = b.lon
    )
)t;
</code></pre>
<p><strong>用 <code>in</code> 替代 <code>=</code></strong></p>
<ul>
<li>保证可以匹配多行 <code>tiv_2015</code>，避免语法错误。</li>
<li>逻辑：只要 <code>a.tiv_2015</code> 在别的记录中出现过，就符合。</li>
</ul>
<p><strong>用 <code>not exists</code> 替代 <code>lat != ... or lon != ...</code></strong></p>
<ul>
<li>若写法是“只要某个纬度不同就通过”，会误判。</li>
<li><strong><code>not exists</code> 的逻辑是“不能存在一条记录跟我纬度和经度都相同”。</strong></li>
</ul>
<p><strong>逻辑清晰且无歧义</strong></p>
<ul>
<li>保证有相同 <code>tiv_2015</code>；</li>
<li>保证没有相同 <code>(lat, lon)</code>。</li>
</ul>
<hr>
<p>补充：</p>
<p>SQL执行顺序：</p>
<ul>
<li><strong>FROM</strong> Employee</li>
<li><strong>WHERE</strong> salary &gt; 5000 （先筛掉工资不够的行）</li>
<li><strong>GROUP BY</strong> dept （按部门分组）</li>
<li><strong>COUNT(*)</strong> 统计每组人数</li>
<li><strong>HAVING</strong> 过滤出人数 ≥3 的部门</li>
<li><strong>SELECT</strong> 输出 dept, cnt</li>
<li><strong>ORDER BY</strong> 按 cnt 降序</li>
<li><strong>LIMIT</strong> 取前 5 个部门</li>
</ul>
<p>char_length(col)返回该列的字符数</p>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 KING!BOB!
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;KING BOB
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    <canvas
    id="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>
    <canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="Jack-Li-Npu/comment"
    data-repo-id="R_kgDOPviQNg"
    data-category="Announcements"
    data-category-id="DIC_kwDOPviQNs4Cva-O"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang=""
    crossorigin
    async
></script>





    
<!-- hexo injector body_end start --><script data-pjax src="https://unpkg.com/oh-my-live2d"></script><script>const oml2d = OML2D.loadOml2d({dockedPosition:"right",mobileDisplay:true,models:[{"path":"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","mobilePosition":[-10,23],"mobileScale":0.1,"mobileStageStyle":{"width":180,"height":166},"motionPreloadStrategy":"IDLE","position":[-10,35],"scale":0.15,"stageStyle":{"width":250,"height":250}},{"path":"https://unpkg.com/live2d-widget-model-koharu@1.0.5/assets/koharu.model.json","scale":0.12,"position":[0,0],"stageStyle":{"width":250},"mobileScale":0.08,"mobilePosition":[0,0],"mobileStageStyle":{"width":180}},{"path":"https://unpkg.com/live2d-widget-model-haruto@1.0.5/assets/haruto.model.json","scale":0.12,"position":[0,0],"mobileScale":0.08,"mobilePosition":[0,0],"mobileStageStyle":{"width":180},"stageStyle":{"width":250}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:false,tips:{style: {"width":230,"height":120,"left":"calc(50% - 20px)","top":"-100px"},mobileStyle: {"width":180,"height":80,"left":"calc(50% - 30px)","top":"-100px"},idleTips:{interval:15000,message:function(){
  return axios.get('https://v1.hitokoto.cn?c=i')
    .then(function (response) {
      return response.data.hitokoto ;
    })
    .catch(function (error) {
      console.error(error);
    });
}
}}});</script><!-- hexo injector body_end end --></body>
</html>
