
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>KING!BOB!</title>
    <meta name="author" content="KING BOB" />
    <meta name="description" content="LET'S MAKE IT HAPPEN" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/pic.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>KING!BOB!</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;KING!BOB!</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background2.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>KING!BOB!</h1>
                <h3></h3>
                <h5>LET&#39;S MAKE IT HAPPEN</h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2022/05/26/Leetcode%20%20sql%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/">
        <h2 class="post-title">Leetcode sql题目记录</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Leetcode/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Leetcode
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/5/26
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="Leetcode-sql题目记录"><a href="#Leetcode-sql题目记录" class="headerlink" title="Leetcode  sql题目记录"></a>Leetcode  sql题目记录</h2><p>本博客仅记录**高频 SQL 50 题（基础版）**中的中等难度题目，后续不定期更新</p>
<h3 id="570-至少有5名直接下属的经理"><a href="#570-至少有5名直接下属的经理" class="headerlink" title="570. 至少有5名直接下属的经理"></a>570. 至少有5名直接下属的经理</h3><p>表: <code>Employee</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| name        | varchar |
| department  | varchar |
| managerId   | int     |
+-------------+---------+
id 是此表的主键（具有唯一值的列）。
该表的每一行表示雇员的名字、他们的部门和他们的经理的id。
如果managerId为空，则该员工没有经理。
没有员工会成为自己的管理者。
</code></pre>
<p>编写一个解决方案，找出至少有<strong>五个直接下属</strong>的经理。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 
Employee 表:
+-----+-------+------------+-----------+
| id  | name  | department | managerId |
+-----+-------+------------+-----------+
| 101 | John  | A          | Null      |
| 102 | Dan   | A          | 101       |
| 103 | James | A          | 101       |
| 104 | Amy   | A          | 101       |
| 105 | Anne  | A          | 101       |
| 106 | Ron   | B          | 101       |
+-----+-------+------------+-----------+
输出: 
+------+
| name |
+------+
| John |
+------+
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">select a.name from Employee a join Employee b on a.id = b.managerId group by a.id having count(*) &gt;= 5;
</code></pre>
<p>没有 <code>GROUP BY</code><br> <code>HAVING</code> 是对<strong>分组后的结果</strong>过滤的。你没分组时，MySQL把整张结果集当成<strong>一个大组</strong>，<code>COUNT(a.id)</code> 统计的是<strong>所有经理–下属配对的总行数</strong>，不是“每个经理的下属数”。因此当测试数据里只有一个经理且刚好有 5 个下属时看起来“正确”，但只要有两个经理，合计行数 ≥5，你这句就会把两位经理都放进结果里，甚至还会重复多行。</p>
<hr>
<h3 id="1934-确认率"><a href="#1934-确认率" class="headerlink" title="1934. 确认率"></a>1934. 确认率</h3><p>表: <code>Signups</code></p>
<pre><code>+----------------+----------+
| Column Name    | Type     |
+----------------+----------+
| user_id        | int      |
| time_stamp     | datetime |
+----------------+----------+
User_id是该表的主键。
每一行都包含ID为user_id的用户的注册时间信息。
</code></pre>
<p>表: <code>Confirmations</code></p>
<pre><code>+----------------+----------+
| Column Name    | Type     |
+----------------+----------+
| user_id        | int      |
| time_stamp     | datetime |
| action         | ENUM     |
+----------------+----------+
(user_id, time_stamp)是该表的主键。
user_id是一个引用到注册表的外键。
action是类型为(&#39;confirmed&#39;， &#39;timeout&#39;)的ENUM
该表的每一行都表示ID为user_id的用户在time_stamp请求了一条确认消息，该确认消息要么被确认(&#39;confirmed&#39;)，要么被过期(&#39;timeout&#39;)。
</code></pre>
<p>用户的 <strong>确认率</strong> 是 <code>&#39;confirmed&#39;</code> 消息的数量除以请求的确认消息的总数。没有请求任何确认消息的用户的确认率为 <code>0</code> 。确认率四舍五入到 <strong>小数点后两位</strong> 。</p>
<p>编写一个SQL查询来查找每个用户的 确认率 。</p>
<p>以 任意顺序 返回结果表。</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例1:</strong></p>
<pre><code>输入：
Signups 表:
+---------+---------------------+
| user_id | time_stamp          |
+---------+---------------------+
| 3       | 2020-03-21 10:16:13 |
| 7       | 2020-01-04 13:57:59 |
| 2       | 2020-07-29 23:09:44 |
| 6       | 2020-12-09 10:39:37 |
+---------+---------------------+
Confirmations 表:
+---------+---------------------+-----------+
| user_id | time_stamp          | action    |
+---------+---------------------+-----------+
| 3       | 2021-01-06 03:30:46 | timeout   |
| 3       | 2021-07-14 14:00:00 | timeout   |
| 7       | 2021-06-12 11:57:29 | confirmed |
| 7       | 2021-06-13 12:58:28 | confirmed |
| 7       | 2021-06-14 13:59:27 | confirmed |
| 2       | 2021-01-22 00:00:00 | confirmed |
| 2       | 2021-02-28 23:59:59 | timeout   |
+---------+---------------------+-----------+
输出: 
+---------+-------------------+
| user_id | confirmation_rate |
+---------+-------------------+
| 6       | 0.00              |
| 3       | 0.00              |
| 7       | 1.00              |
| 2       | 0.50              |
+---------+-------------------+
解释:
用户 6 没有请求任何确认消息。确认率为 0。
用户 3 进行了 2 次请求，都超时了。确认率为 0。
用户 7 提出了 3 个请求，所有请求都得到了确认。确认率为 1。
用户 2 做了 2 个请求，其中一个被确认，另一个超时。确认率为 1 / 2 = 0.5。
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">WITH base AS (
  SELECT 
    user_id,
    COUNT(*) AS total,
    SUM(CASE WHEN action = &#39;confirmed&#39; THEN 1 ELSE 0 END) AS confirmed
  FROM Confirmations
  GROUP BY user_id
)
SELECT 
  s.user_id,
  ROUND(IFNULL(b.confirmed / b.total, 0), 2) AS confirmation_rate
FROM Signups s
LEFT JOIN base b
  ON s.user_id = b.user_id;
</code></pre>
<hr>
<h3 id="1193-每月交易I"><a href="#1193-每月交易I" class="headerlink" title="1193. 每月交易I"></a>1193. 每月交易I</h3><p>表：<code>Transactions</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| country       | varchar |
| state         | enum    |
| amount        | int     |
| trans_date    | date    |
+---------------+---------+
id 是这个表的主键。
该表包含有关传入事务的信息。
state 列类型为 [&quot;approved&quot;, &quot;declined&quot;] 之一。
</code></pre>
<p>编写一个 sql 查询来查找每个月和每个国家&#x2F;地区的事务数及其总金额、已批准的事务数及其总金额。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Transactions table:
+------+---------+----------+--------+------------+
| id   | country | state    | amount | trans_date |
+------+---------+----------+--------+------------+
| 121  | US      | approved | 1000   | 2018-12-18 |
| 122  | US      | declined | 2000   | 2018-12-19 |
| 123  | US      | approved | 2000   | 2019-01-01 |
| 124  | DE      | approved | 2000   | 2019-01-07 |
+------+---------+----------+--------+------------+
输出：
+----------+---------+-------------+----------------+--------------------+-----------------------+
| month    | country | trans_count | approved_count | trans_total_amount | approved_total_amount |
+----------+---------+-------------+----------------+--------------------+-----------------------+
| 2018-12  | US      | 2           | 1              | 3000               | 1000                  |
| 2019-01  | US      | 1           | 1              | 2000               | 2000                  |
| 2019-01  | DE      | 1           | 1              | 2000               | 2000                  |
+----------+---------+-------------+----------------+--------------------+-----------------------+
</code></pre>
<p>解答：</p>
<p>多个 CTE 用 <code>WITH a AS (...), b AS (...)</code>。</p>
<p>按 <code>month、country</code> 分组；<code>approved</code> 相关用 <code>CASE WHEN</code> 计数&#x2F;求和。</p>
<p>取月份用 <code>DATE_FORMAT(trans_date, &#39;%Y-%m&#39;)</code> 更稳妥。</p>
<p><strong>DATE_FORMAT(…, ‘%y-%m’)：结果是20-02，若是’%Y-%m，结果是2020-02，若是’%Y-%M，结果是2020-Febrary’</strong></p>
<pre><code class="language-sql">WITH base AS (
  SELECT
    DATE_FORMAT(trans_date, &#39;%Y-%m&#39;) AS month,
    country,
    state,
    amount
  FROM Transactions
),
seq AS (
  SELECT
    month,
    country,
    COUNT(*) AS trans_count,
    SUM(CASE WHEN state = &#39;approved&#39; THEN 1 ELSE 0 END) AS approved_count,
    SUM(amount) AS trans_total_amount,
    SUM(CASE WHEN state = &#39;approved&#39; THEN amount ELSE 0 END) AS approved_total_amount
  FROM base
  GROUP BY month, country
)
SELECT *
FROM seq;
</code></pre>
<hr>
<h3 id="1174-即时食物配送II"><a href="#1174-即时食物配送II" class="headerlink" title="1174. 即时食物配送II"></a>1174. 即时食物配送II</h3><p>配送表: <code>Delivery</code></p>
<pre><code>+-----------------------------+---------+
| Column Name                 | Type    |
+-----------------------------+---------+
| delivery_id                 | int     |
| customer_id                 | int     |
| order_date                  | date    |
| customer_pref_delivery_date | date    |
+-----------------------------+---------+
delivery_id 是该表中具有唯一值的列。
该表保存着顾客的食物配送信息，顾客在某个日期下了订单，并指定了一个期望的配送日期（和下单日期相同或者在那之后）。
</code></pre>
<p>如果顾客期望的配送日期和下单日期相同，则该订单称为 「<strong>即时订单</strong>」，否则称为「<strong>计划订单</strong>」。</p>
<p>「<strong>首次订单</strong>」是顾客最早创建的订单。我们保证一个顾客只会有一个「首次订单」。</p>
<p>编写解决方案以获取即时订单在所有用户的首次订单中的比例。<strong>保留两位小数。</strong></p>
<p>结果示例如下所示：</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Delivery 表：
+-------------+-------------+------------+-----------------------------+
| delivery_id | customer_id | order_date | customer_pref_delivery_date |
+-------------+-------------+------------+-----------------------------+
| 1           | 1           | 2019-08-01 | 2019-08-02                  |
| 2           | 2           | 2019-08-02 | 2019-08-02                  |
| 3           | 1           | 2019-08-11 | 2019-08-12                  |
| 4           | 3           | 2019-08-24 | 2019-08-24                  |
| 5           | 3           | 2019-08-21 | 2019-08-22                  |
| 6           | 2           | 2019-08-11 | 2019-08-13                  |
| 7           | 4           | 2019-08-09 | 2019-08-09                  |
+-------------+-------------+------------+-----------------------------+
输出：
+----------------------+
| immediate_percentage |
+----------------------+
| 50.00                |
+----------------------+
解释：
1 号顾客的 1 号订单是首次订单，并且是计划订单。
2 号顾客的 2 号订单是首次订单，并且是即时订单。
3 号顾客的 5 号订单是首次订单，并且是计划订单。
4 号顾客的 7 号订单是首次订单，并且是即时订单。
因此，一半顾客的首次订单是即时的。
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">with base as (
select *, row_number() over(partition by customer_id order by order_date) as rn 
from Delivery),
seq as (
    select round((sum(case when customer_pref_delivery_date = order_date then 1 else 0 end) / count(*)) * 100, 2) as immediate_percentage from base where rn = 1
)
select * from seq;
</code></pre>
<hr>
<h3 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a>176. 第二高的薪水</h3><p><code>Employee</code> 表：</p>
<pre><code>+-------------+------+
| Column Name | Type |
+-------------+------+
| id          | int  |
| salary      | int  |
+-------------+------+
id 是这个表的主键。
表的每一行包含员工的工资信息。
</code></pre>
<p>查询并返回 <code>Employee</code> 表中第二高的 <strong>不同</strong> 薪水 。如果不存在第二高的薪水，查询应该返回 <code>null(Pandas 则返回 None)</code> 。</p>
<p>查询结果如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Employee 表：
+----+--------+
| id | salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
输出：
+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：
Employee 表：
+----+--------+
| id | salary |
+----+--------+
| 1  | 100    |
+----+--------+
输出：
+---------------------+
| SecondHighestSalary |
+---------------------+
| null                |
+---------------------+
</code></pre>
<p>解答</p>
<pre><code class="language-sql">SELECT MAX(salary) AS SecondHighestSalary
FROM (
  SELECT DISTINCT salary,
         DENSE_RANK() OVER (ORDER BY salary DESC) AS rk
  FROM Employee
) t
WHERE rk = 2;
</code></pre>
<h4 id="（1）-子查询为空但外层用了聚合函数"><a href="#（1）-子查询为空但外层用了聚合函数" class="headerlink" title="（1） 子查询为空但外层用了聚合函数"></a>（1） 子查询为空但外层用了聚合函数</h4><p>SQL 的定义是：聚合函数对空输入时，返回 <strong>NULL</strong>。<br> 例子：</p>
<pre><code class="language-sql">SELECT MAX(salary) FROM (SELECT 1 AS salary WHERE 1=0) t;
</code></pre>
<p><code>(SELECT 1 WHERE 1=0)</code> 为空表 → <code>MAX</code> 没有任何值可比较 → 返回 <code>NULL</code>。</p>
<p>所以这就是为什么“第二高薪水不存在”时 <code>MAX</code> 可以帮我们自动返回 <code>NULL</code>。</p>
<hr>
<h4 id="（2）子查询为空而外层没有聚合函数"><a href="#（2）子查询为空而外层没有聚合函数" class="headerlink" title="（2）子查询为空而外层没有聚合函数"></a>（2）子查询为空而外层没有聚合函数</h4><p>如果你直接：</p>
<pre><code class="language-sql">SELECT salary 
FROM (SELECT salary WHERE 1=0) t;
</code></pre>
<p>那结果就是 <strong>0 行</strong>（即直接返回空结果集，不会自动给你一行 <code>NULL</code>）。</p>
<hr>
<h3 id="550-游戏玩法分析IV"><a href="#550-游戏玩法分析IV" class="headerlink" title="550. 游戏玩法分析IV"></a>550. 游戏玩法分析IV</h3><p>Table: <code>Activity</code></p>
<pre><code>+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
（player_id，event_date）是此表的主键（具有唯一值的列的组合）。
这张表显示了某些游戏的玩家的活动情况。
每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0）。
</code></pre>
<p>编写解决方案，报告在首次登录的第二天再次登录的玩家的 <strong>比率</strong>，<strong>四舍五入到小数点后两位</strong>。换句话说，你需要计算从首次登录后的第二天登录的玩家数量，并将其除以总玩家数。</p>
<p>结果格式如下所示：</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-03-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+
输出：
+-----------+
| fraction  |
+-----------+
| 0.33      |
+-----------+
解释：
只有 ID 为 1 的玩家在第一天登录后才重新登录，所以答案是 1/3 = 0.33
</code></pre>
<p>解答：</p>
<pre><code class="language-sql"># Write your MySQL query statement below
with base as(
    select *,min(event_date) over(partition by player_id)as first from Activity
),
seq as(
    select player_id, sum(case when datediff(event_date, first) = 1 then 1 else 0 end) as rn from base
    group by player_id
)
select round(IFNULL((sum(rn) / count(distinct player_id)), 0), 2) as fraction from seq;
</code></pre>
<p>注意：</p>
<ol>
<li>在使用with base as(), seq as() select from seq时，要记得每个嵌套内部的select很重要，前一个select需要包含后一个select的内容。</li>
<li>使用聚合函数min,max,count后结果会被压缩，如果后续要同行对最大、最小进行比较，要使用窗口函数形式的max,min…</li>
</ol>
<hr>
<h3 id="1045-买下所有产品的客户"><a href="#1045-买下所有产品的客户" class="headerlink" title="1045. 买下所有产品的客户"></a>1045. 买下所有产品的客户</h3><p><code>Customer</code> 表：</p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| customer_id | int     |
| product_key | int     |
+-------------+---------+
该表可能包含重复的行。
customer_id 不为 NULL。
product_key 是 Product 表的外键(reference 列)。
</code></pre>
<p><code>Product</code> 表：</p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| product_key | int     |
+-------------+---------+
product_key 是这张表的主键（具有唯一值的列）。
</code></pre>
<p>编写解决方案，报告 <code>Customer</code> 表中购买了 <code>Product</code> 表中所有产品的客户的 id。</p>
<p>返回结果表 <strong>无顺序要求</strong> 。</p>
<p>返回结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Customer 表：
+-------------+-------------+
| customer_id | product_key |
+-------------+-------------+
| 1           | 5           |
| 2           | 6           |
| 3           | 5           |
| 3           | 6           |
| 1           | 6           |
+-------------+-------------+
Product 表：
+-------------+
| product_key |
+-------------+
| 5           |
| 6           |
+-------------+
输出：
+-------------+
| customer_id |
+-------------+
| 1           |
| 3           |
+-------------+
解释：
购买了所有产品（5 和 6）的客户的 id 是 1 和 3 。
</code></pre>
<p>解答：</p>
<ol>
<li><strong><code>WHERE DISTINCT</code> 是非法语法</strong>。<code>DISTINCT</code> 只能放在 <code>SELECT</code> 或 <code>COUNT(DISTINCT ...)</code> 里面，不能直接放在 <code>WHERE</code>。</li>
<li>题目要求的是“买了所有产品的顾客”，所以应该比较顾客买到的 <strong>去重后产品数</strong> 和 <strong>Product 表里的产品总数</strong>。</li>
</ol>
<pre><code class="language-sql">SELECT customer_id
FROM Customer
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (
    SELECT COUNT(*) FROM Product
);
</code></pre>
<p>解释一下：</p>
<ul>
<li><code>GROUP BY customer_id</code>：按顾客分组。</li>
<li><code>COUNT(DISTINCT product_key)</code>：统计该顾客买了多少种不同的产品。</li>
<li>子查询 <code>(SELECT COUNT(*) FROM Product)</code>：统计总共有多少种产品。</li>
<li><code>HAVING ... = ...</code>：筛选出买全所有产品的顾客。</li>
</ul>
<hr>
<h3 id="180-连续出现的数字"><a href="#180-连续出现的数字" class="headerlink" title="180. 连续出现的数字"></a>180. 连续出现的数字</h3><p>表：<code>Logs</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| num         | varchar |
+-------------+---------+
在 SQL 中，id 是该表的主键。
id 是一个自增列。
</code></pre>
<p>找出所有至少连续出现三次的数字。</p>
<p>返回的结果表中的数据可以按 <strong>任意顺序</strong> 排列。</p>
<p>结果格式如下面的例子所示：</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Logs 表：
+----+-----+
| id | num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+
输出：
Result 表：
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
解释：1 是唯一连续出现至少三次的数字。
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">with base as(
    select *, row_number() over(partition by num order by id) as rn from Logs
),
seq as(
    select *, id - rn as diff from base 
),
rpq as (
    select num, count(*) as ct from seq group by num, diff having count(*) &gt;= 3
)
select distinct num as ConsecutiveNums from rpq;
</code></pre>
<p><strong>有时候不要忘记distinct</strong></p>
<hr>
<h3 id="1164-指定日期的产品价格"><a href="#1164-指定日期的产品价格" class="headerlink" title="1164. 指定日期的产品价格"></a>1164. 指定日期的产品价格</h3><p>产品数据表: <code>Products</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| new_price     | int     |
| change_date   | date    |
+---------------+---------+
(product_id, change_date) 是此表的主键（具有唯一值的列组合）。
这张表的每一行分别记录了 某产品 在某个日期 更改后 的新价格。
</code></pre>
<p>一开始，所有产品价格都为 10。</p>
<p>编写一个解决方案，找出在 <code>2019-08-16</code> 所有产品的价格。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>结果格式如下例所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Products 表:
+------------+-----------+-------------+
| product_id | new_price | change_date |
+------------+-----------+-------------+
| 1          | 20        | 2019-08-14  |
| 2          | 50        | 2019-08-14  |
| 1          | 30        | 2019-08-15  |
| 1          | 35        | 2019-08-16  |
| 2          | 65        | 2019-08-17  |
| 3          | 20        | 2019-08-18  |
+------------+-----------+-------------+
输出：
+------------+-------+
| product_id | price |
+------------+-------+
| 2          | 50    |
| 1          | 35    |
| 3          | 10    |
+------------+-------+
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">with base as(
    select *, row_number()over (partition by product_id order by change_date DESC) as rn from Products where change_date &lt;= &#39;2019-08-16&#39;
),
seq as (
    select product_id, new_price as price from base where rn = 1
)
select product_id, price from seq union all select distinct product_id, 10 as price from (
    select product_id, min(change_date) as mi from Products group by product_id
)t  where mi &gt; &#39;2019-08-16&#39;;
</code></pre>
<p>归纳：<br>想要得到某一列的最大最小值，并用其与某个数进行比较，需要先max、min（窗口或者聚合函数），然后再等值查询，或者rownumber配合ASC、DESC，然后再后续查询中使用rn&#x3D;1，或者直接使用order by+limit</p>
<h4 id="（1）非相关子查询-等值比较"><a href="#（1）非相关子查询-等值比较" class="headerlink" title="（1）非相关子查询 + 等值比较"></a>（1）非相关子查询 + 等值比较</h4><p><strong>使用场景</strong>：<strong>全局只有一个最值</strong>（整个表的最大值&#x2F;最小值），不依赖分组。</p>
<ul>
<li>特点：子查询返回单行，可以直接用 <code>=</code> 比较。</li>
<li>示例：找出工资最高的员工</li>
</ul>
<pre><code class="language-sql">select *
from Employee
where salary = (select max(salary) from Employee);
</code></pre>
<hr>
<h4 id="（2）相关子查询"><a href="#（2）相关子查询" class="headerlink" title="（2）相关子查询"></a>（2）相关子查询</h4><p><strong>使用场景</strong>：<strong>分组后的最值</strong>（每个客户&#x2F;部门的最小&#x2F;最大日期），外层表的条件依赖子查询。</p>
<ul>
<li>特点：子查询里需要引用外层的列，每行执行一次，保证返回单行。</li>
<li>示例：找每个客户的首单</li>
</ul>
<pre><code class="language-sql">select *
from Delivery d1
where order_date = (
  select min(order_date)
  from Delivery d2
  where d2.customer_id = d1.customer_id
);
</code></pre>
<p>这里子查询里的 <code>d2.customer_id = d1.customer_id</code> 绑定了外层查询的 <code>d1.customer_id</code>。</p>
<p>每次外层取一行，子查询就只计算该客户的最小订单日期。</p>
<p>也可以写成这种形式：</p>
<pre><code class="language-sql">select *
from (
  select customer_id, min(order_date)
  from Delivery 
  group by customer_id
)t ;
</code></pre>
<hr>
<h4 id="（3）窗口函数-条件筛选"><a href="#（3）窗口函数-条件筛选" class="headerlink" title="（3）窗口函数 + 条件筛选"></a>（3）窗口函数 + 条件筛选</h4><p><strong>使用场景</strong>：数据库支持窗口函数（MySQL 8+ &#x2F; PostgreSQL &#x2F; Oracle &#x2F; SQL Server），<strong>需要按组取前几名&#x2F;最值。</strong></p>
<p>也可以使用max、min的窗口函数形式来获取每个组别的最值</p>
<ul>
<li>特点：写法简洁，可同时保留分组内排序信息。</li>
<li>示例：找每个客户的首单</li>
</ul>
<pre><code class="language-sql">with t as (
  select *,
         row_number() over(partition by customer_id order by order_date) as rn
  from Delivery
)
select *
from t
where rn = 1;
</code></pre>
<ul>
<li>如果要处理并列情况，可以用 <code>rank()</code> 或 <code>dense_rank()</code>。</li>
</ul>
<hr>
<h4 id="（4）ORDER-BY-LIMIT"><a href="#（4）ORDER-BY-LIMIT" class="headerlink" title="（4）ORDER BY + LIMIT"></a>（4）ORDER BY + LIMIT</h4><p><strong>使用场景</strong>：<strong>只需要全表范围内的最值</strong>，且只取前 N 条（不分组）。</p>
<ul>
<li>特点：简单高效，但无法直接应对「每组最值」问题。</li>
<li>示例：找工资最高的员工（Top 1）</li>
</ul>
<pre><code class="language-sql">select *
from Employee
order by salary desc
limit 1;
</code></pre>
<ul>
<li>如果需要每组最值，就不适合，只能配合窗口函数或子查询。</li>
</ul>
<hr>
<h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><table>
<thead>
<tr>
<th>方法</th>
<th>适用场景</th>
<th>优点</th>
<th>局限</th>
</tr>
</thead>
<tbody><tr>
<td><strong>非相关子查询</strong></td>
<td>全表唯一最值</td>
<td>简单</td>
<td>只能处理单个全局最值</td>
</tr>
<tr>
<td><strong>相关子查询</strong></td>
<td>每组最值（需要依赖外层条件）</td>
<td>通用，不要求窗口函数</td>
<td>子查询多次执行，性能较差</td>
</tr>
<tr>
<td><strong>窗口函数</strong></td>
<td>每组最值&#x2F;前 N 个</td>
<td>高效简洁，现代 SQL 推荐</td>
<td>需要数据库支持窗口函数</td>
</tr>
<tr>
<td><strong>ORDER BY + LIMIT</strong></td>
<td>全表前 N 个</td>
<td>简洁高效</td>
<td>不能分组，只能处理全局最值</td>
</tr>
</tbody></table>
<hr>
<p>👉 快速记忆：</p>
<ul>
<li><strong>全局最值</strong> → 非相关子查询 或 <code>order by + limit</code></li>
<li><strong>分组最值</strong> → 相关子查询 或 窗口函数</li>
<li><strong>要前 N 名&#x2F;并列情况</strong> → 窗口函数最佳</li>
</ul>
<hr>
<h3 id="1204-最后一个能进入巴士的人"><a href="#1204-最后一个能进入巴士的人" class="headerlink" title="1204.最后一个能进入巴士的人"></a>1204.最后一个能进入巴士的人</h3><p>表: <code>Queue</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| person_id   | int     |
| person_name | varchar |
| weight      | int     |
| turn        | int     |
+-------------+---------+
person_id 是这个表具有唯一值的列。
该表展示了所有候车乘客的信息。
表中 person_id 和 turn 列将包含从 1 到 n 的所有数字，其中 n 是表中的行数。
turn 决定了候车乘客上巴士的顺序，其中 turn=1 表示第一个上巴士，turn=n 表示最后一个上巴士。
weight 表示候车乘客的体重，以千克为单位。
</code></pre>
<p>有一队乘客在等着上巴士。然而，巴士有<code>1000</code> <strong>千克</strong> 的重量限制，所以其中一部分乘客可能无法上巴士。</p>
<p>编写解决方案找出 <strong>最后一个</strong> 上巴士且不超过重量限制的乘客，并报告 <code>person_name</code> 。题目测试用例确保顺位第一的人可以上巴士且不会超重。</p>
<p>返回结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Queue 表
+-----------+-------------+--------+------+
| person_id | person_name | weight | turn |
+-----------+-------------+--------+------+
| 5         | Alice       | 250    | 1    |
| 4         | Bob         | 175    | 5    |
| 3         | Alex        | 350    | 2    |
| 6         | John Cena   | 400    | 3    |
| 1         | Winston     | 500    | 6    |
| 2         | Marie       | 200    | 4    |
+-----------+-------------+--------+------+
输出：
+-------------+
| person_name |
+-------------+
| John Cena   |
+-------------+
解释：
为了简化，Queue 表按 turn 列由小到大排序。
+------+----+-----------+--------+--------------+
| Turn | ID | Name      | Weight | Total Weight |
+------+----+-----------+--------+--------------+
| 1    | 5  | Alice     | 250    | 250          |
| 2    | 3  | Alex      | 350    | 600          |
| 3    | 6  | John Cena | 400    | 1000         | (最后一个上巴士)
| 4    | 2  | Marie     | 200    | 1200         | (无法上巴士)
| 5    | 4  | Bob       | 175    | ___          |
| 6    | 1  | Winston   | 500    | ___          |
+------+----+-----------+--------+--------------+
</code></pre>
<p>解答：</p>
<p><strong>PS：SQL 聚合函数（如 <code>MAX()</code>）和普通列之间没有自动的“行对齐”关系。</strong></p>
<p>不能直接写成！：</p>
<pre><code class="language-sql">select person_name, max(total_weight) from (
    select * , sum(weight)over (order by turn) as total_weight from Queue
)t where total_weight &lt;= 1000;

-- 结果只会返回
| person_id | person_name | weight | turn |
| --------- | ----------- | ------ | ---- |
| 5         | Alice       | 250    | 1    |
| 4         | Bob         | 175    | 5    |
| 3         | Alex        | 350    | 2    |
| 6         | John Cena   | 400    | 3    |
| 1         | Winston     | 500    | 6    |
| 2         | Marie       | 200    | 4    |

| person_name | max(total_weight) |
| ----------- | ----------------- |
| Alice       | 1000              |

-- 而不是正确输出
| person_name |
| ----------- |
| John Cena   |
</code></pre>
<h4 id="（1）子查询-等值过滤"><a href="#（1）子查询-等值过滤" class="headerlink" title="（1）子查询+等值过滤"></a>（1）子查询+等值过滤</h4><pre><code class="language-sql"># Write your MySQL query statement below
with base as(
    select * , sum(weight)over (order by turn) as total_weight from Queue
)
select person_name from base where total_weight = (
    select max(total_weight) as mx from base where total_weight &lt;= 1000
);
</code></pre>
<hr>
<h4 id="（2）ORDER-BY-LIMIT"><a href="#（2）ORDER-BY-LIMIT" class="headerlink" title="（2）ORDER BY+LIMIT"></a>（2）ORDER BY+LIMIT</h4><pre><code class="language-sql"># Write your MySQL query statement below
select person_name from (
    select * , sum(weight)over (order by turn) as total_weight from Queue
)t where total_weight &lt;= 1000 order by total_weight DESC limit 1;
</code></pre>
<hr>
<h3 id="1907-按分类统计薪水"><a href="#1907-按分类统计薪水" class="headerlink" title="1907. 按分类统计薪水"></a>1907. 按分类统计薪水</h3><p>表: <code>Accounts</code></p>
<pre><code>+-------------+------+
| 列名        | 类型  |
+-------------+------+
| account_id  | int  |
| income      | int  |
+-------------+------+
在 SQL 中，account_id 是这个表的主键。
每一行都包含一个银行帐户的月收入的信息。
</code></pre>
<p>查询每个工资类别的银行账户数量。 工资类别如下：</p>
<ul>
<li><code>&quot;Low Salary&quot;</code>：所有工资 <strong>严格低于</strong> <code>20000</code> 美元。</li>
<li><code>&quot;Average Salary&quot;</code>： <strong>包含</strong> 范围内的所有工资 <code>[$20000, $50000]</code> 。</li>
<li><code>&quot;High Salary&quot;</code>：所有工资 <strong>严格大于</strong> <code>50000</code> 美元。</li>
</ul>
<p>结果表 <strong>必须</strong> 包含所有三个类别。 如果某个类别中没有帐户，则报告 <code>0</code> 。</p>
<p>按 <strong>任意顺序</strong> 返回结果表。</p>
<p>查询结果格式如下示例。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Accounts 表:
+------------+--------+
| account_id | income |
+------------+--------+
| 3          | 108939 |
| 2          | 12747  |
| 8          | 87709  |
| 6          | 91796  |
+------------+--------+
输出：
+----------------+----------------+
| category       | accounts_count |
+----------------+----------------+
| Low Salary     | 1              |
| Average Salary | 0              |
| High Salary    | 3              |
+----------------+----------------+
解释：
低薪: 有一个账户 2.
中等薪水: 没有.
高薪: 有三个账户，他们是 3, 6和 8.
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">select &#39;Low Salary&#39; as category, sum(case when income &lt; 20000 then 1 else 0 end) as accounts_count
from Accounts
Union all
select &#39;Average Salary&#39; as category, sum(case when income &gt;= 20000 and income &lt;= 50000 then 1 else 0 end) as accounts_count
from Accounts
Union all
select &#39;High Salary&#39; as category, sum(case when income &gt; 50000 then 1 else 0 end) as accounts_count
from Accounts;
</code></pre>
<hr>
<h3 id="626-换座位"><a href="#626-换座位" class="headerlink" title="626. 换座位"></a>626. 换座位</h3><p>表: <code>Seat</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| student     | varchar |
+-------------+---------+
id 是该表的主键（唯一值）列。
该表的每一行都表示学生的姓名和 ID。
ID 序列始终从 1 开始并连续增加。
</code></pre>
<p>编写解决方案来交换每两个连续的学生的座位号。如果学生的数量是奇数，则最后一个学生的id不交换。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 
Seat 表:
+----+---------+
| id | student |
+----+---------+
| 1  | Abbot   |
| 2  | Doris   |
| 3  | Emerson |
| 4  | Green   |
| 5  | Jeames  |
+----+---------+
输出: 
+----+---------+
| id | student |
+----+---------+
| 1  | Doris   |
| 2  | Abbot   |
| 3  | Green   |
| 4  | Emerson |
| 5  | Jeames  |
+----+---------+
解释:
请注意，如果学生人数为奇数，则不需要更换最后一名学生的座位。
</code></pre>
<p>解答：</p>
<h4 id="（1）嵌套查询"><a href="#（1）嵌套查询" class="headerlink" title="（1）嵌套查询"></a>（1）嵌套查询</h4><pre><code class="language-sql"># Write your MySQL query statement below
with base as(
    select *, lead(student, 1)over (order by id) as exchange_nxt, lag(student, 1)over (order by id) as exchange_pre from Seat
)
select id, IFNULL((case when (id % 2) != 0 then exchange_nxt else exchange_pre end), student) as student from base;
</code></pre>
<h4 id="（2）CASE-WHEN"><a href="#（2）CASE-WHEN" class="headerlink" title="（2）CASE WHEN"></a>（2）CASE WHEN</h4><pre><code class="language-sql"># Write your MySQL query statement below
select case 
        when id % 2 = 1 and id &lt; (select max(id) from Seat)
            then id + 1
        when id % 2 = 0 
            then id - 1
        else id
        end as id, student
    from Seat
order by id;
</code></pre>
<p>在 SQL 里，<code>CASE</code> 可以写两种形式：</p>
<h5 id="a-简单-CASE"><a href="#a-简单-CASE" class="headerlink" title="a. 简单 CASE"></a>a. 简单 CASE</h5><p>直接对某个表达式的值做匹配：</p>
<pre><code class="language-sql">CASE column_name
    WHEN &#39;A&#39; THEN &#39;类型1&#39;
    WHEN &#39;B&#39; THEN &#39;类型2&#39;
    ELSE &#39;其他&#39;
END
</code></pre>
<h5 id="b-搜索-CASE-（最常用）"><a href="#b-搜索-CASE-（最常用）" class="headerlink" title="b. 搜索 CASE （最常用）"></a>b. 搜索 CASE （最常用）</h5><p>条件判断灵活，可以写比较、范围等：</p>
<pre><code class="language-sql">CASE
    WHEN score &gt;= 90 THEN &#39;优秀&#39;
    WHEN score &gt;= 60 THEN &#39;及格&#39;
    ELSE &#39;不及格&#39;
END
</code></pre>
<h5 id="c-作为一个字段输出"><a href="#c-作为一个字段输出" class="headerlink" title="c. 作为一个字段输出"></a>c. 作为一个字段输出</h5><pre><code class="language-sql">SELECT name,
       CASE WHEN age &lt; 18 THEN &#39;未成年&#39;
            WHEN age &lt; 60 THEN &#39;成年人&#39;
            ELSE &#39;老年人&#39;
       END AS age_group
FROM users;
</code></pre>
<h5 id="d-在聚合函数里做条件统计"><a href="#d-在聚合函数里做条件统计" class="headerlink" title="d. 在聚合函数里做条件统计"></a>d. 在聚合函数里做条件统计</h5><pre><code class="language-sql">SELECT
    SUM(CASE WHEN status = &#39;success&#39; THEN 1 ELSE 0 END) AS success_count,
    SUM(CASE WHEN status = &#39;fail&#39; THEN 1 ELSE 0 END)    AS fail_count
FROM logs;
</code></pre>
<p>常用于 <strong>条件计数</strong>。</p>
<h5 id="e-排序（ORDER-BY）"><a href="#e-排序（ORDER-BY）" class="headerlink" title="e. 排序（ORDER BY）"></a>e. 排序（ORDER BY）</h5><pre><code class="language-sql">SELECT *
FROM orders
ORDER BY
  CASE 
    WHEN status = &#39;vip&#39; THEN 1
    WHEN status = &#39;normal&#39; THEN 2
    ELSE 3
  END;
</code></pre>
<hr>
<h3 id="1341-电影评分"><a href="#1341-电影评分" class="headerlink" title="1341. 电影评分"></a>1341. 电影评分</h3><p>表：<code>Movies</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| movie_id      | int     |
| title         | varchar |
+---------------+---------+
movie_id 是这个表的主键(具有唯一值的列)。
title 是电影的名字。
</code></pre>
<p>表：<code>Users</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user_id       | int     |
| name          | varchar |
+---------------+---------+
user_id 是表的主键(具有唯一值的列)。
&#39;name&#39; 列具有唯一值。
</code></pre>
<p>表：<code>MovieRating</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| movie_id      | int     |
| user_id       | int     |
| rating        | int     |
| created_at    | date    |
+---------------+---------+
(movie_id, user_id) 是这个表的主键(具有唯一值的列的组合)。
这个表包含用户在其评论中对电影的评分 rating 。
created_at 是用户的点评日期。 
</code></pre>
<p>请你编写一个解决方案：</p>
<ul>
<li>查找评论电影数量最多的用户名。如果出现平局，返回字典序较小的用户名。</li>
<li>查找在 <code>February 2020</code> <strong>平均评分最高</strong> 的电影名称。如果出现平局，返回字典序较小的电影名称。</li>
</ul>
<p><strong>字典序</strong> ，即按字母在字典中出现顺序对字符串排序，字典序较小则意味着排序靠前。</p>
<p>返回结果格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Movies 表：
+-------------+--------------+
| movie_id    |  title       |
+-------------+--------------+
| 1           | Avengers     |
| 2           | Frozen 2     |
| 3           | Joker        |
+-------------+--------------+
Users 表：
+-------------+--------------+
| user_id     |  name        |
+-------------+--------------+
| 1           | Daniel       |
| 2           | Monica       |
| 3           | Maria        |
| 4           | James        |
+-------------+--------------+
MovieRating 表：
+-------------+--------------+--------------+-------------+
| movie_id    | user_id      | rating       | created_at  |
+-------------+--------------+--------------+-------------+
| 1           | 1            | 3            | 2020-01-12  |
| 1           | 2            | 4            | 2020-02-11  |
| 1           | 3            | 2            | 2020-02-12  |
| 1           | 4            | 1            | 2020-01-01  |
| 2           | 1            | 5            | 2020-02-17  | 
| 2           | 2            | 2            | 2020-02-01  | 
| 2           | 3            | 2            | 2020-03-01  |
| 3           | 1            | 3            | 2020-02-22  | 
| 3           | 2            | 4            | 2020-02-25  | 
+-------------+--------------+--------------+-------------+
输出：
Result 表：
+--------------+
| results      |
+--------------+
| Daniel       |
| Frozen 2     |
+--------------+
解释：
Daniel 和 Monica 都点评了 3 部电影（&quot;Avengers&quot;, &quot;Frozen 2&quot; 和 &quot;Joker&quot;） 但是 Daniel 字典序比较小。
Frozen 2 和 Joker 在 2 月的评分都是 3.5，但是 Frozen 2 的字典序比较小。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">with base as(
    select *, avg(rating) as avg_rate from (
        select *, date_format(created_at, &#39;%Y-%m&#39;) as created_month from MovieRating 
        where date_format(created_at, &#39;%Y-%m&#39;) = &#39;2020-02&#39;
    )a group by movie_id
),
seq as (
    select movie_id from base where avg_rate = (
        select max(avg_rate) from base 
    )
),
base2 as(
    select s.user_id from(
        select t.user_id, rank() over(order by ct DESC) as rk from(
            select user_id, count(*) as ct from  MovieRating group by user_id
        )t
    )s where s.rk = 1
)
select min(a.name) as results from Users a join base2 b on a.user_id = b.user_id union all
    select min(a.title) as results from Movies a join seq b on a.movie_id = b.movie_id;
</code></pre>
<p><strong>PS:</strong></p>
<p>（1）如果需要获取某一列中不同值的总数，eg:id列1,2,3出现的次数，可以</p>
<pre><code class="language-sql">select count(*) from emp group by id
</code></pre>
<p>（2）等值子查询只能返回一个结果，子查询里select的数值不能超过一行</p>
<hr>
<h3 id="1321-餐厅营业额变化增长"><a href="#1321-餐厅营业额变化增长" class="headerlink" title="1321. 餐厅营业额变化增长"></a>1321. 餐厅营业额变化增长</h3><p>表: <code>Customer</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| customer_id   | int     |
| name          | varchar |
| visited_on    | date    |
| amount        | int     |
+---------------+---------+
在 SQL 中，(customer_id, visited_on) 是该表的主键。
该表包含一家餐馆的顾客交易数据。
visited_on 表示 (customer_id) 的顾客在 visited_on 那天访问了餐馆。
amount 是一个顾客某一天的消费总额。
</code></pre>
<p>你是餐馆的老板，现在你想分析一下可能的营业额变化增长（每天至少有一位顾客）。</p>
<p>计算以 7 天（某日期 + 该日期前的 6 天）为一个时间段的顾客消费平均值。<code>average_amount</code> 要 <strong>保留两位小数。</strong></p>
<p>结果按 <code>visited_on</code> <strong>升序排序</strong>。</p>
<p>返回结果格式的例子如下。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Customer 表:
+-------------+--------------+--------------+-------------+
| customer_id | name         | visited_on   | amount      |
+-------------+--------------+--------------+-------------+
| 1           | Jhon         | 2019-01-01   | 100         |
| 2           | Daniel       | 2019-01-02   | 110         |
| 3           | Jade         | 2019-01-03   | 120         |
| 4           | Khaled       | 2019-01-04   | 130         |
| 5           | Winston      | 2019-01-05   | 110         | 
| 6           | Elvis        | 2019-01-06   | 140         | 
| 7           | Anna         | 2019-01-07   | 150         |
| 8           | Maria        | 2019-01-08   | 80          |
| 9           | Jaze         | 2019-01-09   | 110         | 
| 1           | Jhon         | 2019-01-10   | 130         | 
| 3           | Jade         | 2019-01-10   | 150         | 
+-------------+--------------+--------------+-------------+
输出：
+--------------+--------------+----------------+
| visited_on   | amount       | average_amount |
+--------------+--------------+----------------+
| 2019-01-07   | 860          | 122.86         |
| 2019-01-08   | 840          | 120            |
| 2019-01-09   | 840          | 120            |
| 2019-01-10   | 1000         | 142.86         |
+--------------+--------------+----------------+
解释：
第一个七天消费平均值从 2019-01-01 到 2019-01-07 是restaurant-growth/restaurant-growth/ (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.86
第二个七天消费平均值从 2019-01-02 到 2019-01-08 是 (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 120
第三个七天消费平均值从 2019-01-03 到 2019-01-09 是 (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 120
第四个七天消费平均值从 2019-01-04 到 2019-01-10 是 (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">select visited_on, total_amount as amount, round(total_amount / 7, 2) as average_amount from( 
    select visited_on, sum(new_amount)over (order by visited_on ROWS 6 PRECEDING) total_amount from (
        select visited_on, sum(amount) new_amount from Customer group by visited_on
    )s
)t where visited_on &gt;= (
    select min(visited_on) + 6 from Customer
);
</code></pre>
<p>窗口函数可以选择操作数据的范围</p>
<p>eg：</p>
<pre><code class="language-sql">取当前行和前五行：ROWS between 5 preceding and current row --共6行
取当前行和后五行：ROWS between current row and 5 following --共6行
取前五行和后五行：ROWS between 5 preceding and 5 folowing --共11行
</code></pre>
<hr>
<h3 id="602-好友申请ll：谁有最多的好友"><a href="#602-好友申请ll：谁有最多的好友" class="headerlink" title="602.好友申请ll：谁有最多的好友"></a>602.好友申请ll：谁有最多的好友</h3><p><code>RequestAccepted</code> 表：</p>
<pre><code>+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| requester_id   | int     |
| accepter_id    | int     |
| accept_date    | date    |
+----------------+---------+
(requester_id, accepter_id) 是这张表的主键(具有唯一值的列的组合)。
这张表包含发送好友请求的人的 ID ，接收好友请求的人的 ID ，以及好友请求通过的日期。
</code></pre>
<p>编写解决方案，找出拥有最多的好友的人和他拥有的好友数目。</p>
<p>生成的测试用例保证拥有最多好友数目的只有 1 个人。</p>
<p>查询结果格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
RequestAccepted 表：
+--------------+-------------+-------------+
| requester_id | accepter_id | accept_date |
+--------------+-------------+-------------+
| 1            | 2           | 2016/06/03  |
| 1            | 3           | 2016/06/08  |
| 2            | 3           | 2016/06/08  |
| 3            | 4           | 2016/06/09  |
+--------------+-------------+-------------+
输出：
+----+-----+
| id | num |
+----+-----+
| 3  | 3   |
+----+-----+
解释：
编号为 3 的人是编号为 1 ，2 和 4 的人的好友，所以他总共有 3 个好友，比其他人都多。
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">with base as (
    select accepter_id, count(*) as accepted_num 
    from RequestAccepted 
    group by accepter_id
),
seq as (
    select requester_id, count(*) as requested_num 
    from RequestAccepted 
    group by requester_id
),
seq1 as (
    -- 左连接
    select a.accepter_id as id, 
           ifnull(a.accepted_num,0) + ifnull(b.requested_num,0) as num
    from base a 
    left join seq b on a.accepter_id = b.requester_id
    
    union
    
    -- 右连接（补齐右边独有的行）
    select b.requester_id as id, 
           ifnull(a.accepted_num,0) + ifnull(b.requested_num,0) as num
    from base a 
    right join seq b on a.accepter_id = b.requester_id
)
select id, num
from seq1
where num = (select max(num) from seq1);
</code></pre>
<ul>
<li><code>union</code> 保证把两边独有的 id 都保留下来，等价于 FULL OUTER JOIN。</li>
<li><code>ifnull(...,0)</code> 是避免 NULL 相加导致结果为 NULL。</li>
<li>最后取最大值即可。</li>
</ul>
<hr>
<h3 id="585-2016年的投资"><a href="#585-2016年的投资" class="headerlink" title="585.2016年的投资"></a>585.2016年的投资</h3><p><code>Insurance</code> 表：</p>
<pre><code>+-------------+-------+
| Column Name | Type  |
+-------------+-------+
| pid         | int   |
| tiv_2015    | float |
| tiv_2016    | float |
| lat         | float |
| lon         | float |
+-------------+-------+
pid 是这张表的主键(具有唯一值的列)。
表中的每一行都包含一条保险信息，其中：
pid 是投保人的投保编号。
tiv_2015 是该投保人在 2015 年的总投保金额，tiv_2016 是该投保人在 2016 年的总投保金额。
lat 是投保人所在城市的纬度。题目数据确保 lat 不为空。
lon 是投保人所在城市的经度。题目数据确保 lon 不为空。
</code></pre>
<p>编写解决方案报告 2016 年 (<code>tiv_2016</code>) 所有满足下述条件的投保人的投保金额之和：</p>
<ul>
<li>他在 2015 年的投保额 (<code>tiv_2015</code>) 至少跟一个其他投保人在 2015 年的投保额相同。</li>
<li>他所在的城市必须与其他投保人都不同（也就是说 (<code>lat, lon</code>) 不能跟其他任何一个投保人完全相同）。</li>
</ul>
<p><code>tiv_2016</code> 四舍五入的 <strong>两位小数</strong> 。</p>
<p>查询结果格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Insurance 表：
+-----+----------+----------+-----+-----+
| pid | tiv_2015 | tiv_2016 | lat | lon |
+-----+----------+----------+-----+-----+
| 1   | 10       | 5        | 10  | 10  |
| 2   | 20       | 20       | 20  | 20  |
| 3   | 10       | 30       | 20  | 20  |
| 4   | 10       | 40       | 40  | 40  |
+-----+----------+----------+-----+-----+
输出：
+----------+
| tiv_2016 |
+----------+
| 45.00    |
+----------+
解释：
表中的第一条记录和最后一条记录都满足两个条件。
tiv_2015 值为 10 与第三条和第四条记录相同，且其位置是唯一的。

第二条记录不符合任何一个条件。其 tiv_2015 与其他投保人不同，并且位置与第三条记录相同，这也导致了第三条记录不符合题目要求。
因此，结果是第一条记录和最后一条记录的 tiv_2016 之和，即 45 。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select round(sum(tiv_2016), 2) as tiv_2016 from (
    select a.pid, a.tiv_2016 from Insurance a where a.tiv_2015 in (
        select b.tiv_2015 from Insurance b where a.pid &lt;&gt; b.pid
    ) and not exists (
        select 1 
        from Insurance b 
        where a.pid &lt;&gt; b.pid 
        and a.lat = b.lat 
        and a.lon = b.lon
    )
)t;
</code></pre>
<p><strong>用 <code>in</code> 替代 <code>=</code></strong></p>
<ul>
<li>保证可以匹配多行 <code>tiv_2015</code>，避免语法错误。</li>
<li>逻辑：只要 <code>a.tiv_2015</code> 在别的记录中出现过，就符合。</li>
</ul>
<p><strong>用 <code>not exists</code> 替代 <code>lat != ... or lon != ...</code></strong></p>
<ul>
<li>若写法是“只要某个纬度不同就通过”，会误判。</li>
<li><strong><code>not exists</code> 的逻辑是“不能存在一条记录跟我纬度和经度都相同”。</strong></li>
</ul>
<p><strong>逻辑清晰且无歧义</strong></p>
<ul>
<li>保证有相同 <code>tiv_2015</code>；</li>
<li>保证没有相同 <code>(lat, lon)</code>。</li>
</ul>
<hr>
<p>补充：</p>
<p>SQL执行顺序：</p>
<ul>
<li><strong>FROM</strong> Employee</li>
<li><strong>WHERE</strong> salary &gt; 5000 （先筛掉工资不够的行）</li>
<li><strong>GROUP BY</strong> dept （按部门分组）</li>
<li><strong>COUNT(*)</strong> 统计每组人数</li>
<li><strong>HAVING</strong> 过滤出人数 ≥3 的部门</li>
<li><strong>SELECT</strong> 输出 dept, cnt</li>
<li><strong>ORDER BY</strong> 按 cnt 降序</li>
<li><strong>LIMIT</strong> 取前 5 个部门</li>
</ul>
<p>char_length(col)返回该列的字符数</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Leetcode/" style="color: #00a596">Leetcode</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/SQL/" style="color: #ffa2c4">SQL</a>
        </span>
        
    </div>
    <a href="/2022/05/26/Leetcode%20%20sql%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2021/12/13/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/">
        <h2 class="post-title">数据建模</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                数据建模
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2021/12/13
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="1. 数据预处理"></a>1. 数据预处理</h2><h3 id="（1）数据清洗"><a href="#（1）数据清洗" class="headerlink" title="（1）数据清洗"></a>（1）数据清洗</h3><h4 id="1-1-缺失值处理"><a href="#1-1-缺失值处理" class="headerlink" title="1.1 缺失值处理"></a>1.1 缺失值处理</h4><h4 id="1-2-异常值处理"><a href="#1-2-异常值处理" class="headerlink" title="1.2 异常值处理"></a>1.2 异常值处理</h4><h4 id="1-3-数据规约"><a href="#1-3-数据规约" class="headerlink" title="1.3 数据规约"></a>1.3 数据规约</h4><h4 id="1-4-数据变换"><a href="#1-4-数据变换" class="headerlink" title="1.4 数据变换"></a>1.4 数据变换</h4><h2 id="1-数据分析"><a href="#1-数据分析" class="headerlink" title="1. 数据分析"></a>1. 数据分析</h2><h3 id="（1）初步分析"><a href="#（1）初步分析" class="headerlink" title="（1）初步分析"></a>（1）初步分析</h3><h5 id="查看样例数据"><a href="#查看样例数据" class="headerlink" title="查看样例数据"></a>查看样例数据</h5><p>data.head(5)</p>
<h5 id="查看形状"><a href="#查看形状" class="headerlink" title="查看形状"></a>查看形状</h5><p>data.shape()</p>
<h3 id="（2）质量分析"><a href="#（2）质量分析" class="headerlink" title="（2）质量分析"></a>（2）质量分析</h3><h5 id="判断唯一索引是否有重复值"><a href="#判断唯一索引是否有重复值" class="headerlink" title="判断唯一索引是否有重复值"></a>判断唯一索引是否有重复值</h5><p>data[‘ . ‘].nunique() &#x3D;&#x3D; data.shape[0]</p>
<h5 id="缺失值检验"><a href="#缺失值检验" class="headerlink" title="缺失值检验"></a>缺失值检验</h5><p>data.isnull().sum()</p>
<h5 id="异常值检测"><a href="#异常值检测" class="headerlink" title="异常值检测"></a>异常值检测</h5><p>​	打印各个属性的直方图</p>
<pre><code class="language-python">sns.set()
for col in cols:
    statistic = data.describe()
    plt.figure(figsize=(6,6))
    sns.hisplot(data[col], kde=True) # kde核密度曲线，若与直方图走向一致则说明没有异常值
    plt.title...
    plt.show()
</code></pre>
<h5 id="规律一致性检测"><a href="#规律一致性检测" class="headerlink" title="规律一致性检测"></a>规律一致性检测</h5><p>对于单变量且离散数据，可以用以下的方法进行简要判断</p>
<p>​	判断train表与test表是否出自同一分布</p>
<pre><code class="language-python">train_count = train.shape[0]
test_count = test.shape[0]
features = [&#39;Pclass&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;]

i = 1
plt.figure(figsize=(18, 18))
for feature in features:
    plt.subplot(3, 3, i)
    (train[feature].value_counts().sort_index()/train_count).plot()
    (test[feature].value_counts().sort_index()/test_count).plot()
    plt.legend([&#39;train&#39;, &#39;test&#39;])
    plt.xlabel(feature)
    plt.ylabel(&#39;radio&#39;)
    plt.show
    i+=1
</code></pre>
<p>同时还可以进行多变量联合分布</p>
<p>指的是将离散变量两两组合，然后查看这个新变量的相对占比分布。例如特征1有0&#x2F;1两个取值水平，特征2有A&#x2F;B两个取值水平，则联合分布中就将存在0A、0B、1A、1B四种不同取值水平，然后进一步查看这四种不同取值水平出现的分布情况。</p>
<pre><code class="language-python">def combine_feature(df):
    cols = df.columns
    feature1 = df[cols[0]].astype(str).values.tolist()
    feature2 = df[cols[1]].astype(str).values.tolist()
    return pd.Series([feature1[i]+&#39;&amp;&#39;+feature2[i] for i in range(df.shape[0])])

cols = [features[0], features[1]]

# 查看合并后结果
train_com = combine_feature(train[cols])

train_dis = train_com.value_counts().sort_index()/train_count
test_dis = combine_feature(test[cols]).value_counts().sort_index()/test_count

# 创建新的index
index_dis = pd.Series(train_dis.index.tolist() + test_dis.index.tolist()).drop_duplicates().sort_values()

# 对缺失值填补为0
(index_dis.map(train_dis).fillna(0)).plot()
(index_dis.map(train_dis).fillna(0)).plot()

# 绘图
plt.legend([&#39;train&#39;,&#39;test&#39;])
plt.xlabel(&#39;&amp;&#39;.join(cols))
plt.ylabel(&#39;ratio&#39;)
plt.show()
</code></pre>
<h2 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2. 数据预处理"></a>2. 数据预处理</h2><h3 id="（1）缺失值填充"><a href="#（1）缺失值填充" class="headerlink" title="（1）缺失值填充"></a>（1）缺失值填充</h3><p>分别依据情况将缺失值填充为均值或众数（对于离散型数据）或前向后向值（对于连续型数据）</p>
<pre><code class="language-python">data[col] = data[col].fillna(data[col].mean()/data[col].mode()[0])

data[col].ffill(inplcae=True)# 前向填充
data[col].bfill(inplace=True)# 后向填充
</code></pre>
<h3 id="（2）将object类型转换为字典编码"><a href="#（2）将object类型转换为字典编码" class="headerlink" title="（2）将object类型转换为字典编码"></a>（2）将object类型转换为字典编码</h3><p>data.info()查看数据类型</p>
<pre><code class="language-python">def change_object_cols(se):
    # 1. 获取该列的唯一值，并转成列表
    value = se.unique().tolist()
    
    # 2. 对唯一值排序，保证编码的顺序固定（从小到大）
    value.sort()
    
    # 3. 构造一个映射表：唯一值 → 数字索引
    #    例如：[&#39;C&#39;, &#39;Q&#39;, &#39;S&#39;] → &#123; &#39;C&#39;:0, &#39;Q&#39;:1, &#39;S&#39;:2 &#125;
    mapping = pd.Series(range(len(value)), index=value)
    
    # 4. 将原始序列 se 映射成数值序列
    return se.map(mapping).values


for col in cols:
    data[col] = change_object_cols(col)
</code></pre>
<h2 id="3-特征工程"><a href="#3-特征工程" class="headerlink" title="3. 特征工程"></a>3. 特征工程</h2><h3 id="（1）确定离散、连续变量"><a href="#（1）确定离散、连续变量" class="headerlink" title="（1）确定离散、连续变量"></a>（1）确定离散、连续变量</h3><p>这是个很好的问题 👍。在 Kaggle 这种建模比赛里，区分 <strong>离散字段（categorical features）</strong> 和 <strong>连续字段（numerical features）</strong> 是特征工程的第一步，直接影响后续的编码方式、特征衍生、模型效果。一般的经验如下：</p>
<hr>
<ol>
<li><strong>离散字段（Categorical Features）的判定</strong></li>
</ol>
<p>常见特征类型：</p>
<ul>
<li><strong>字符串型</strong>：比如性别（Sex）、职业（job_title）。</li>
<li><strong>整数型但取值有限</strong>：例如舱位等级（Pclass: 1&#x2F;2&#x2F;3）、星期几（1–7）、地区编号。</li>
<li><strong>ID类特征</strong>：如 PassengerId、订单号，虽然是字符串&#x2F;数字，但每个取值都唯一 → 通常丢弃或转化为计数特征。</li>
</ul>
<p>📌 经验：</p>
<ul>
<li><strong>唯一值数量远小于样本数</strong>（如几种类别，而不是几千上万），基本都算离散变量。</li>
<li><strong>整数型变量</strong>要小心，比如邮编、编号，它们表面是数字，其实是分类特征。</li>
<li><strong>高基数特征</strong>（类别数太多）：<ul>
<li>可以尝试 <strong>频率编码（frequency encoding）</strong></li>
<li>或 <strong>target encoding &#x2F; mean encoding</strong>（比赛里常用，但要注意泄露，要交叉验证编码）</li>
</ul>
</li>
</ul>
<hr>
<ol start="2">
<li><strong>连续字段（Numerical Features）的判定</strong></li>
</ol>
<p>常见特征类型：</p>
<ul>
<li><strong>实数型</strong>：身高、体重、金额、时间差。</li>
<li><strong>取值范围大且近似连续的整数</strong>：年龄（0–100）、乘客数量、房价。</li>
</ul>
<p>📌 经验：</p>
<ul>
<li>数值的大小 <strong>有顺序且差值有意义</strong>（例如价格 100 和 200 相差一倍） → 连续特征。</li>
<li>对于这些特征，常用的处理包括：<ul>
<li>标准化（StandardScaler）、归一化（MinMaxScaler）</li>
<li>分箱（binning），转化为类别 → 提高树模型稳定性</li>
</ul>
</li>
</ul>
<hr>
<ol start="3">
<li><strong>混合情况（容易误判的字段）</strong></li>
</ol>
<ul>
<li><strong>Age（年龄）</strong>：是连续的，但可以尝试分箱（儿童&#x2F;青年&#x2F;中年&#x2F;老年），当做离散变量。</li>
<li><strong>Fare（票价）</strong>：连续型，但分布通常长尾，可以对数化（log transform）。</li>
<li><strong>Cabin（船舱号）</strong>：原始是字符串（离散），但如果只取首字母（A&#x2F;B&#x2F;C&#x2F;D&#x2F;E&#x2F;F），相当于类别。</li>
</ul>
<p>📌 Kaggle 常见技巧：</p>
<ul>
<li><strong>连续变量离散化</strong>（binning）后有时比直接用效果更好，尤其在树模型中。</li>
<li>同一个特征既保留原始数值，又加一个分箱类别特征，让模型自己选择。</li>
</ul>
<hr>
<ol start="4">
<li><strong>比赛经验总结</strong></li>
</ol>
<ul>
<li><strong>EDA（探索性数据分析）优先</strong>：先用 <code>describe()</code>、<code>value_counts()</code>、直方图、箱线图，直观判断分布。</li>
<li><strong>看唯一值个数（nunique）</strong>：<ul>
<li>nunique ≪ 样本数 → 倾向离散</li>
<li>nunique ≈ 样本数 → 可能是 ID，直接舍弃或做 count encoding</li>
</ul>
</li>
<li><strong>树模型 vs 线性模型的不同</strong>：<ul>
<li>树模型（LightGBM、XGBoost、CatBoost）：不太怕离散编码（甚至 CatBoost 可以直接处理类别）。</li>
<li>线性模型、神经网络：更依赖标准化和 One-Hot。</li>
</ul>
</li>
<li><strong>比赛 Top 选手习惯</strong>：同一个特征会做多种处理方式（原始连续 &#x2F; 分箱类别 &#x2F; 平滑编码），让模型选择。</li>
</ul>
<hr>
<p>✅ <strong>一句话经验</strong>：</p>
<ul>
<li>“值的大小有顺序和间距意义 → 连续特征”</li>
<li>“值只是标签、没有数值含义 → 离散特征”</li>
<li>模型前期：多做几种处理方式（连续 &#x2F; 离散化 &#x2F; target encoding），交给模型和 CV 去筛选。</li>
</ul>
<h3 id="（2）连续变量处理："><a href="#（2）连续变量处理：" class="headerlink" title="（2）连续变量处理："></a>（2）连续变量处理：</h3><h4 id="无穷值处理："><a href="#无穷值处理：" class="headerlink" title="无穷值处理："></a>无穷值处理：</h4><p>天花板盖帽法：即将inf改为最大的显式数值</p>
<pre><code class="language-python">inf_cols = [&#39;avg_purchases_lag3&#39;, &#39;avg_purchases_lag6&#39;, &#39;avg_purchases_lag12&#39;]
merchant[inf_cols] = merchant[inf_cols].replace(np.inf, merchant[inf_cols].replace(np.inf, -99).max().max())
</code></pre>
<p>整体流程</p>
<ol>
<li>拿到数据及其对应的解释，划分连续型字段与离散型字段，重点关注object类型，是否存在时序类型、文本类型字段</li>
<li>正确性校验：是否unique</li>
<li>特征变化：连续变量：考虑是否归一化、分箱，离散型变量：考虑是否要独热编码、自然数编码</li>
<li>考虑缺失值：（1）numpy.NAN；（2）none；（3）特殊缺失值：空格（可能会被识别转换成字符串）——&gt;业务方面的判断。</li>
</ol>
<p>用均值、众数、预测值进行填充。或者可以先用特殊字符代表，比如说离散性数据进行独热编码后可以用-1表示缺失值</p>
<ol start="5">
<li>异常值分析：识别方式：（1）三倍标准差（对于趋近于标准正态分布的数据）、（2）箱线图法；处理方法：（1）天花板盖帽法；（2）单独识别异常值为某一类</li>
</ol>
<p>特征工程：</p>
<p>（2）根据业务进行扩展：eg：金额连续型——&gt;均值、总额、方差、偏度、离散型——&gt;众数…</p>
<p>根据业务含义划分离散字段category_cols与连续字段numeric_cols。</p>
<p>对非数值型的离散字段进行字典排序编码。</p>
<p>为了能够更方便统计，进行缺失值的处理，对离散字段统一用-1进行填充。</p>
<p>对离散型字段探查发现有正无穷值，这是特征提取以及模型所不能接受的，因此需要对无限值进行处理，此处采用最大值进行替换。</p>
<p>去除与transaction交易记录表格重复的列，以及merchant_id的重复记录。</p>
<p>特征工程</p>
<p>通过特征工程新建了很多特征，包含了一些冗余、稀疏特征，虽然最终选用树模型时都可以筛选出最有效的特征，但是过多的特征会影响到建模的效率。因此需要我们提前进行特征筛选，根据与标签相关性初筛出特征。</p>
<p>初筛：<br>Filter相关系数特征筛选方法</p>
<p>使用corr，得出前300个特征</p>
<p>模型训练需要与超参数的选定过程绑定在一起（使模型具有一定的泛化能力）</p>
<p><strong>Filter 特征筛选</strong>：通过统计指标（相关性、卡方检验、互信息等）先对原始特征进行“粗筛”，去掉明显无关或冗余的特征。</p>
<p><strong>随机森林建模</strong>：用筛选后的特征训练一个随机森林模型，得到基准性能。</p>
<p><strong>网格搜索调优</strong>：在筛选后的特征集上，用交叉验证和网格搜索寻找随机森林的最佳超参数组合。</p>
<p>Wrapper方法</p>
<p><strong>Wrapper 特征筛选</strong>：利用模型性能作为评价标准，逐步选择或剔除特征（例如递归特征消除 RFE）。</p>
<p><strong>LightGBM 建模</strong>：用筛选出的特征训练 LightGBM 模型，作为基准模型。</p>
<p><strong>TPE 调优</strong>：通过贝叶斯优化（TPE 算法）高效搜索 LightGBM 的超参数，提升性能。</p>
<p>使用tpe调优前，最好先用warpper方法训练一次lgb先</p>
<p><strong>Voting 是一种固定规则的集成方法，通过对多个基模型的预测结果直接做多数投票（分类）或平均（回归）来得到最终输出；而 Stacking 则是更灵活的堆叠方法，它把多个基模型的预测结果作为新的特征，再训练一个“元学习器”去自动学习最优的加权组合方式，从而通常能比简单投票获得更强的泛化性能。</strong></p>
<p>Stacking流程：在第一层训练过程中，每一个基模型经过5折交叉验证后会得到5个训练集上结果拼接成的验证集结果，以及5个测试集上的结果平均后的总测试集结果，之后在第二层学习过程中，所有基模型的验证集结果作为训练的x，目标是真实标签y，然后学习x的权重参数a，最终对所有基模型的总测试集结果应用学习完毕的权重a进行组合得到最终结果</p>
<hr>
<h4 id="🔹-第一层（基模型训练）"><a href="#🔹-第一层（基模型训练）" class="headerlink" title="🔹 第一层（基模型训练）"></a>🔹 第一层（基模型训练）</h4><ul>
<li>每个基模型做 <strong>5 折交叉验证</strong>：<ul>
<li><strong>训练集 OOF 预测</strong>：每一折的验证集预测拼接 → 得到完整的 OOF 预测结果（对应训练集所有样本）。</li>
<li><strong>测试集预测</strong>：每一折在训练完毕后对测试集预测 → 5 次预测结果取平均，得到该基模型在测试集上的最终预测。</li>
</ul>
</li>
</ul>
<p>👉 输出：</p>
<ul>
<li><code>OOF_i</code>：基模型 i 的训练集预测（n 行 1 列）。</li>
<li><code>Test_i</code>：基模型 i 的测试集预测（m 行 1 列）。</li>
</ul>
<hr>
<h4 id="🔹-第二层（元学习器）"><a href="#🔹-第二层（元学习器）" class="headerlink" title="🔹 第二层（元学习器）"></a>🔹 第二层（元学习器）</h4><ul>
<li><p><strong>输入特征 X</strong>：所有基模型的 OOF 拼接 → 维度 <code>(n, k)</code>，k 为基模型数量。</p>
</li>
<li><p><strong>目标 y</strong>：真实标签（n 行 1 列）。</p>
</li>
<li><p><strong>训练</strong>：用贝叶斯岭回归（或别的模型）学习一个函数：</p>
<p>y^&#x3D;a1⋅OOF1+a2⋅OOF2+⋯+ak⋅OOFk+b\hat{y} &#x3D; a_1 \cdot OOF_1 + a_2 \cdot OOF_2 + \dots + a_k \cdot OOF_k + b</p>
</li>
</ul>
<p>👉 元学习器本质上是在学习一组 <strong>权重参数 a</strong>，告诉我们“每个基模型在最终预测中该占多大比重”。</p>
<hr>
<h4 id="🔹-最终预测"><a href="#🔹-最终预测" class="headerlink" title="🔹 最终预测"></a>🔹 最终预测</h4><ul>
<li><p>把学习到的权重 a 应用到测试集的预测：</p>
<p>y^test&#x3D;a1⋅Test1+a2⋅Test2+⋯+ak⋅Testk+b\hat{y}_{test} &#x3D; a_1 \cdot Test_1 + a_2 \cdot Test_2 + \dots + a_k \cdot Test_k + b</p>
</li>
</ul>
<p>👉 最终结果就是 <strong>测试集上各基模型预测结果的加权组合</strong>。</p>
<p>交叉验证（Cross Validation，简称 CV）是一种常用的模型评估方法，用来检验机器学习模型在<strong>未见过的数据上的泛化能力</strong>。它的核心思想是：把已有的数据集划分成多个部分，轮流用其中一部分做验证集，剩余部分做训练集，最终综合评估结果。</p>
<hr>
<h4 id="为什么需要交叉验证？"><a href="#为什么需要交叉验证？" class="headerlink" title="为什么需要交叉验证？"></a>为什么需要交叉验证？</h4><p>如果只用一次<strong>训练集 &#x2F; 测试集划分</strong>来评估模型，结果可能会受到划分方式的偶然性影响（比如某次划分刚好测试集比较难）。交叉验证通过多次划分并取平均，可以更稳定地反映模型的真实性能。</p>
<hr>
<h4 id="常见的交叉验证方法"><a href="#常见的交叉验证方法" class="headerlink" title="常见的交叉验证方法"></a>常见的交叉验证方法</h4><ol>
<li><strong>k 折交叉验证（k-Fold CV）</strong><ul>
<li>将数据集平均分成 k 份。</li>
<li>每次用其中 1 份作为验证集，剩下 k-1 份作为训练集。</li>
<li>重复 k 次，得到 k 个结果，取平均值作为最终性能。</li>
<li>常见选择：k &#x3D; 5 或 10。</li>
</ul>
</li>
<li><strong>留一交叉验证（LOOCV, Leave-One-Out CV）</strong><ul>
<li>特殊情况：k 等于样本数。</li>
<li>每次只留 1 个样本做验证，其余作为训练。</li>
<li>计算量大，但对小样本数据很有用。</li>
</ul>
</li>
<li><strong>分层交叉验证（Stratified k-Fold CV）</strong><ul>
<li>用于分类问题。</li>
<li>保证每折中的类别比例与整体数据集一致，避免某些类别在某折中消失。</li>
</ul>
</li>
<li><strong>重复交叉验证（Repeated k-Fold CV）</strong><ul>
<li>在 k 折交叉验证的基础上，重复多次（每次随机划分）。</li>
<li>可以进一步降低划分的偶然性。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="交叉验证的优点"><a href="#交叉验证的优点" class="headerlink" title="交叉验证的优点"></a>交叉验证的优点</h4><ul>
<li>更稳定和可靠的性能估计。</li>
<li>避免单次划分可能造成的高估或低估。</li>
<li>在样本较少时能更充分利用数据。</li>
</ul>
<hr>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>假设有 100 条数据，采用 <strong>5 折交叉验证</strong>：</p>
<ul>
<li>第一次：第 1–20 条做验证，21–100 条做训练。</li>
<li>第二次：第 21–40 条做验证，其他做训练。</li>
<li>…依此类推，总共 5 次。<br> 最后取 5 次验证结果的平均作为模型最终得分。</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/" style="color: #00bcd4">数据建模</a>
        </span>
        
    </div>
    <a href="/2021/12/13/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2021/11/15/%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%9C%AF%E8%AF%AD/">
        <h2 class="post-title">统计分析术语</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                统计分析
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2021/11/15
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="统计分析术语"><a href="#统计分析术语" class="headerlink" title="统计分析术语"></a>统计分析术语</h2><ol>
<li>二分位数</li>
<li>第一四分位数</li>
</ol>
<hr>
<p><strong>箱型图解读要点</strong></p>
<ol>
<li><strong>异常值</strong><ul>
<li>如果数据存在离群点（超出 [Q1−1.5⋅IQR,Q3+1.5⋅IQR][Q1-1.5·IQR, Q3+1.5·IQR] 的范围），会在箱型图外以圆点或星号标注。</li>
</ul>
</li>
<li><strong>箱体高度（IQR &#x3D; Q3 – Q1）</strong><ul>
<li><strong>箱子很短</strong>：数据高度集中，分布较均匀。</li>
<li><strong>箱子很长</strong>：数据分布离散，差异较大。</li>
</ul>
</li>
<li><strong>中位数位置</strong><ul>
<li><strong>中位数接近箱体底部（Q1）</strong>：说明数据偏大（右偏，长尾在高值方向）。</li>
<li><strong>中位数接近箱体顶部（Q3）</strong>：说明数据偏小（左偏，长尾在低值方向）。</li>
<li>中位数是否居中，可以反映数据的 <strong>偏斜程度</strong>。</li>
</ul>
</li>
<li><strong>上下须（Whiskers）长度</strong><ul>
<li>须比较长：说明四分位数之外的数据差异较大 → <strong>方差、标准差大</strong>。</li>
<li>须比较短：说明四分位数之外的数据较集中。</li>
</ul>
</li>
<li><strong>箱型图的边缘并不是极值</strong><ul>
<li>箱体的边缘是 <strong>Q1、Q3</strong>，而不是最小值、最大值。</li>
<li>须的终点才接近“最大值&#x2F;最小值”，但仍可能不是极值（因为须长度有限制）。</li>
</ul>
</li>
</ol>
<hr>
<p>📌 <strong>一句话记忆</strong>：</p>
<ul>
<li><strong>箱子 &#x3D; 中心 50% 数据</strong>，</li>
<li><strong>线（须） &#x3D; 更广的分布范围</strong>，</li>
<li><strong>点 &#x3D; 异常值</strong>，</li>
<li><strong>中位数位置 &#x3D; 偏斜方向</strong>。</li>
</ul>
<ol>
<li>假设检验</li>
<li>显著性水平：当原假设为真时，拒绝原假设的概率</li>
<li>功效：当原假设为假时，能检测出这种错误并得出正确结论的概率</li>
<li>置信区间：用来估计总体参数可能范围的一个区间，反映了我们对总体参数估计的信任度</li>
<li>p值：出现极端情况的概率，当原假设为真时，出现比当前抽样分布更加极端的情况的概率</li>
<li>p与$\alpha$的关系：p小于a，则小概率事件发生，则拒绝H0</li>
<li>一类错误：当零假设为真时，拒绝</li>
<li>二类错误：当零假设为假时，接受</li>
<li>原假设与备择假设</li>
<li>中心极限定理</li>
<li>大数定理：随着试验次数的增加，样本平均值趋近总体的期望值</li>
<li>卡方检验：分析变量之间是否独立</li>
<li>方差分析：比较三个或更多的均值是否差异</li>
<li>z检验适用于大样本，总体方差已知</li>
<li>t检验适用于小样本，总体方差未知</li>
<li>最大似然估计</li>
<li>最小二乘估计</li>
<li>交叉验证</li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/" style="color: #ffa2c4">统计分析</a>
        </span>
        
    </div>
    <a href="/2021/11/15/%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%9C%AF%E8%AF%AD/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2021/09/09/Leetcode%20%20sql%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%952/">
        <h2 class="post-title">Leetcode sql题目记录2</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                数据库
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2021/9/9
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="Leetcode-sql题目记录2"><a href="#Leetcode-sql题目记录2" class="headerlink" title="Leetcode  sql题目记录2"></a>Leetcode  sql题目记录2</h2><p>本博客仅记录**高频 SQL 50 题（进阶版）**中的中等难度题目，后续不定期更新</p>
<h3 id="1398-购买了产品A和产品B却没有购买产品C的顾客"><a href="#1398-购买了产品A和产品B却没有购买产品C的顾客" class="headerlink" title="1398.购买了产品A和产品B却没有购买产品C的顾客"></a>1398.购买了产品A和产品B却没有购买产品C的顾客</h3><p> <code>Customers</code> 表：</p>
<pre><code>+---------------------+---------+
| Column Name         | Type    |
+---------------------+---------+
| customer_id         | int     |
| customer_name       | varchar |
+---------------------+---------+
customer_id 是这张表中具有唯一值的列。
customer_name 是顾客的名称。
</code></pre>
<p><code>Orders</code> 表：</p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| customer_id   | int     |
| product_name  | varchar |
+---------------+---------+
order_id 是这张表中具有唯一值的列。
customer_id 是购买了名为 &quot;product_name&quot; 产品顾客的id。
</code></pre>
<p>请你编写解决方案，报告购买了产品 <strong>“A”</strong>，<strong>“B”</strong> 但没有购买产品 <strong>“C”</strong> 的客户的 customer_id 和 customer_name，因为我们想推荐他们购买这样的产品。</p>
<p>返回按 <code>customer_id</code> <strong>排序</strong> 的结果表。</p>
<p>返回结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Customers table:
+-------------+---------------+
| customer_id | customer_name |
+-------------+---------------+
| 1           | Daniel        |
| 2           | Diana         |
| 3           | Elizabeth     |
| 4           | Jhon          |
+-------------+---------------+

Orders table:
+------------+--------------+---------------+
| order_id   | customer_id  | product_name  |
+------------+--------------+---------------+
| 10         |     1        |     A         |
| 20         |     1        |     B         |
| 30         |     1        |     D         |
| 40         |     1        |     C         |
| 50         |     2        |     A         |
| 60         |     3        |     A         |
| 70         |     3        |     B         |
| 80         |     3        |     D         |
| 90         |     4        |     C         |
+------------+--------------+---------------+
输出：
+-------------+---------------+
| customer_id | customer_name |
+-------------+---------------+
| 3           | Elizabeth     |
+-------------+---------------+
解释：
只有 customer_id 为 3 的顾客购买了产品 A 和产品 B ，却没有购买产品 C 。
</code></pre>
<p><strong>解答：</strong></p>
<p><strong>（1）最基础解法，逐一子查询</strong></p>
<pre><code class="language-sql">SELECT c.customer_id, c.customer_name
FROM Customers c
WHERE EXISTS (
    SELECT 1 FROM Orders o WHERE o.customer_id = c.customer_id AND o.product_name = &#39;A&#39;
)
AND EXISTS (
    SELECT 1 FROM Orders o WHERE o.customer_id = c.customer_id AND o.product_name = &#39;B&#39;
)
AND NOT EXISTS (
    SELECT 1 FROM Orders o WHERE o.customer_id = c.customer_id AND o.product_name = &#39;C&#39;
);
</code></pre>
<p>注意：在判断某列不在某个子查询的结果列表里时，如果子查询里有null值，则not in会返回空。因此需要用not exists。</p>
<p>当 <code>NOT IN</code> 拆成多个比较后，如果其中有一个条件返回 <code>UNKNOWN</code>，整个 AND 结果就不是 <code>TRUE</code>，而是 <strong>UNKNOWN</strong>，最终这条记录就被过滤掉。</p>
<p>举例：</p>
<ul>
<li><code>col1 = 10</code><br> 检查 <code>10 &lt;&gt; 5</code> → TRUE<br> 检查 <code>10 &lt;&gt; NULL</code> → UNKNOWN<br> <code>TRUE AND UNKNOWN</code> → UNKNOWN → 不返回</li>
</ul>
<p>所以只要子查询里有 <code>NULL</code>，所有外层行都会因为遇到 <code>UNKNOWN</code> 被排除掉，结果就是空集</p>
<p><strong>（2）一次扫 Orders 做条件聚合，再跟 Customers 关联</strong></p>
<pre><code class="language-sql">SELECT c.customer_id, c.customer_name
FROM Customers c
JOIN Orders o ON o.customer_id = c.customer_id
GROUP BY c.customer_id, c.customer_name
HAVING SUM(o.product_name = &#39;A&#39;) &gt; 0
   AND SUM(o.product_name = &#39;B&#39;) &gt; 0
   AND SUM(o.product_name = &#39;C&#39;) = 0
ORDER BY c.customer_id;
</code></pre>
<hr>
<h3 id="1112-每位学生的最高成绩"><a href="#1112-每位学生的最高成绩" class="headerlink" title="1112.每位学生的最高成绩"></a>1112.每位学生的最高成绩</h3><p>表：<code>Enrollments</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| student_id    | int     |
| course_id     | int     |
| grade         | int     |
+---------------+---------+
(student_id, course_id) 是该表的主键（具有唯一值的列的组合）。
grade 不会为 NULL。
</code></pre>
<p>编写解决方案，找出每位学生获得的最高成绩和它所对应的科目，若科目成绩并列，取 <code>course_id</code> 最小的一门。查询结果需按 <code>student_id</code> 增序进行排序。</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Enrollments 表：
+------------+-------------------+
| student_id | course_id | grade |
+------------+-----------+-------+
| 2          | 2         | 95    |
| 2          | 3         | 95    |
| 1          | 1         | 90    |
| 1          | 2         | 99    |
| 3          | 1         | 80    |
| 3          | 2         | 75    |
| 3          | 3         | 82    |
+------------+-----------+-------+
输出：
+------------+-------------------+
| student_id | course_id | grade |
+------------+-----------+-------+
| 1          | 2         | 99    |
| 2          | 2         | 95    |
| 3          | 3         | 82    |
+------------+-----------+-------+
</code></pre>
<p><strong>解答</strong>：</p>
<pre><code class="language-sql">select student_id, min(course_id)as course_id, grade from(
    select *, max(grade) over(partition by student_id) as max_score from Enrollments
)t where grade = max_score group by student_id, grade order by student_id;
</code></pre>
<hr>
<h3 id="1440-计算布尔表达式的值"><a href="#1440-计算布尔表达式的值" class="headerlink" title="1440.计算布尔表达式的值"></a>1440.计算布尔表达式的值</h3><p>表 <code>Variables</code>:</p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| name          | varchar |
| value         | int     |
+---------------+---------+
在 SQL 中，name 是该表主键.
该表包含了存储的变量及其对应的值.
</code></pre>
<p>表 <code>Expressions</code>:</p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| left_operand  | varchar |
| operator      | enum    |
| right_operand | varchar |
+---------------+---------+
在 SQL 中，(left_operand, operator, right_operand) 是该表主键.
该表包含了需要计算的布尔表达式.
operator 是枚举类型, 取值于(&#39;&lt;&#39;, &#39;&gt;&#39;, &#39;=&#39;)
left_operand 和 right_operand 的值保证存在于 Variables 表单中.
</code></pre>
<p>计算表 <code>Expressions</code> 中的布尔表达式。</p>
<p>返回的结果表 <strong>无顺序要求</strong> 。</p>
<p>结果格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Variables 表:
+------+-------+
| name | value |
+------+-------+
| x    | 66    |
| y    | 77    |
+------+-------+

Expressions 表:
+--------------+----------+---------------+
| left_operand | operator | right_operand |
+--------------+----------+---------------+
| x            | &gt;        | y             |
| x            | &lt;        | y             |
| x            | =        | y             |
| y            | &gt;        | x             |
| y            | &lt;        | x             |
| x            | =        | x             |
+--------------+----------+---------------+

输出:
+--------------+----------+---------------+-------+
| left_operand | operator | right_operand | value |
+--------------+----------+---------------+-------+
| x            | &gt;        | y             | false |
| x            | &lt;        | y             | true  |
| x            | =        | y             | false |
| y            | &gt;        | x             | true  |
| y            | &lt;        | x             | false |
| x            | =        | x             | true  |
+--------------+----------+---------------+-------+
解释：
如上所示, 你需要通过使用 Variables 表来找到 Expressions 表中的每一个布尔表达式的值.
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">SELECT e.left_operand,
       e.operator,
       e.right_operand,
       CASE
           WHEN e.operator = &#39;&gt;&#39; AND v1.value &gt; v2.value THEN &#39;true&#39;
           WHEN e.operator = &#39;&lt;&#39; AND v1.value &lt; v2.value THEN &#39;true&#39;
           WHEN e.operator = &#39;=&#39; AND v1.value = v2.value THEN &#39;true&#39;
           ELSE &#39;false&#39;
       END AS value
FROM Expressions e
JOIN Variables v1 ON e.left_operand = v1.name
JOIN Variables v2 ON e.right_operand = v2.name;
</code></pre>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li><code>JOIN Variables v1</code> → 获取左操作数的值。</li>
<li><code>JOIN Variables v2</code> → 获取右操作数的值。</li>
<li><code>CASE</code> 里根据不同运算符进行比较，返回 <code>true</code> 或 <code>false</code>。</li>
</ul>
<p>这样写就能正确对比 <strong>数值</strong>，而不是对比变量名字符串。</p>
<hr>
<h3 id="1212-查询球队积分（列转行）"><a href="#1212-查询球队积分（列转行）" class="headerlink" title="1212.查询球队积分（列转行）"></a>1212.查询球队积分（列转行）</h3><p>表: <code>Teams</code></p>
<pre><code>+---------------+----------+
| Column Name   | Type     |
+---------------+----------+
| team_id       | int      |
| team_name     | varchar  |
+---------------+----------+
team_id 是该表具有唯一值的列。
表中的每一行都代表一支独立足球队。
</code></pre>
<p>表: <code>Matches</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| match_id      | int     |
| host_team     | int     |
| guest_team    | int     | 
| host_goals    | int     |
| guest_goals   | int     |
+---------------+---------+
match_id 是该表具有唯一值的列。
表中的每一行都代表一场已结束的比赛。
比赛的主客队分别由它们自己的 id 表示，他们的进球由 host_goals 和 guest_goals 分别表示。
</code></pre>
<p>你希望在所有比赛之后计算所有球队的比分。积分奖励方式如下:</p>
<ul>
<li>如果球队赢了比赛(即比对手进更多的球)，就得 <strong>3</strong> 分。</li>
<li>如果双方打成平手(即，与对方得分相同)，则得 <strong>1</strong> 分。</li>
<li>如果球队输掉了比赛(例如，比对手少进球)，就 <strong>不得分</strong> 。</li>
</ul>
<p>编写解决方案，以找出每个队的 <code>team_id</code>，<code>team_name</code> 和 <code>num_points</code>。</p>
<p>返回的结果根据 <code>num_points</code> <strong>降序排序</strong>，如果有两队积分相同，那么这两队按 <code>team_id</code> <strong>升序排序</strong>。</p>
<p>返回结果格式如下。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Teams table:
+-----------+--------------+
| team_id   | team_name    |
+-----------+--------------+
| 10        | Leetcode FC  |
| 20        | NewYork FC   |
| 30        | Atlanta FC   |
| 40        | Chicago FC   |
| 50        | Toronto FC   |
+-----------+--------------+
Matches table:
+------------+--------------+---------------+-------------+--------------+
| match_id   | host_team    | guest_team    | host_goals  | guest_goals  |
+------------+--------------+---------------+-------------+--------------+
| 1          | 10           | 20            | 3           | 0            |
| 2          | 30           | 10            | 2           | 2            |
| 3          | 10           | 50            | 5           | 1            |
| 4          | 20           | 30            | 1           | 0            |
| 5          | 50           | 30            | 1           | 0            |
+------------+--------------+---------------+-------------+--------------+
输出：
+------------+--------------+---------------+
| team_id    | team_name    | num_points    |
+------------+--------------+---------------+
| 10         | Leetcode FC  | 7             |
| 20         | NewYork FC   | 3             |
| 50         | Toronto FC   | 3             |
| 30         | Atlanta FC   | 1             |
| 40         | Chicago FC   | 0             |
+------------+--------------+---------------+
</code></pre>
<p>解答：</p>
<pre><code class="language-sql">
SELECT t.team_id,
       t.team_name,
       IFNULL(SUM(score), 0) AS num_points
FROM Teams t
LEFT JOIN (
    SELECT host_team AS team_id,
           CASE 
               WHEN host_goals &gt; guest_goals THEN 3
               WHEN host_goals = guest_goals THEN 1
               ELSE 0 
           END AS score
    FROM Matches
    UNION ALL
    SELECT guest_team AS team_id,
           CASE 
               WHEN guest_goals &gt; host_goals THEN 3
               WHEN guest_goals = host_goals THEN 1
               ELSE 0 
           END AS score
    FROM Matches
) m ON t.team_id = m.team_id
GROUP BY t.team_id, t.team_name
ORDER BY num_points DESC, t.team_id;
</code></pre>
<ul>
<li><p>没有结果（null）则返回0——&gt;IFNULL(col, 0)</p>
</li>
<li><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><ol>
<li><code>UNION ALL</code><ul>
<li>第一段取主队（<code>host_team</code>），根据比分计算积分。</li>
<li>第二段取客队（<code>guest_team</code>），同样计算积分。</li>
<li>这样每场比赛会贡献两行数据（主队、客队）。</li>
</ul>
</li>
<li>外层再 <code>JOIN Teams</code> → 确保所有球队都显示，即使一场没打过。</li>
<li><code>GROUP BY</code> 聚合积分，<code>ORDER BY num_points DESC, team_id</code> 保证排序符合要求。</li>
</ol>
</li>
</ul>
<p><strong>（列转行）分组后同一组的不同列数值要进行数学操作，可以用union all将不同列转换为同一列在行的方向拼接，再使用窗口函数得到结果</strong></p>
<hr>
<h3 id="1445-苹果和桔子（行转列）"><a href="#1445-苹果和桔子（行转列）" class="headerlink" title="1445. 苹果和桔子（行转列）"></a>1445. 苹果和桔子（行转列）</h3><p>表: <code>Sales</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| sale_date     | date    |
| fruit         | enum    | 
| sold_num      | int     | 
+---------------+---------+
(sale_date, fruit) 是该表主键(具有唯一值的列的组合)。
该表包含了每一天中&quot;苹果&quot; 和 &quot;桔子&quot;的销售情况。
</code></pre>
<p>编写解决方案报告每一天 <strong>苹果</strong> 和 <strong>桔子</strong> 销售的数目的差异.</p>
<p>返回的结果表, 按照格式为 (‘YYYY-MM-DD’) 的 <code>sale_date</code> 排序.</p>
<p>返回结果表如下例所示:</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Sales 表:
+------------+------------+-------------+
| sale_date  | fruit      | sold_num    |
+------------+------------+-------------+
| 2020-05-01 | apples     | 10          |
| 2020-05-01 | oranges    | 8           |
| 2020-05-02 | apples     | 15          |
| 2020-05-02 | oranges    | 15          |
| 2020-05-03 | apples     | 20          |
| 2020-05-03 | oranges    | 0           |
| 2020-05-04 | apples     | 15          |
| 2020-05-04 | oranges    | 16          |
+------------+------------+-------------+
输出：
+------------+--------------+
| sale_date  | diff         |
+------------+--------------+
| 2020-05-01 | 2            |
| 2020-05-02 | 0            |
| 2020-05-03 | 20           |
| 2020-05-04 | -1           |
+------------+--------------+
解释：
在 2020-05-01, 卖了 10 个苹果 和 8 个桔子 (差异为 10 - 8 = 2).
在 2020-05-02, 卖了 15 个苹果 和 15 个桔子 (差异为 15 - 15 = 0).
在 2020-05-03, 卖了 20 个苹果 和 0 个桔子 (差异为 20 - 0 = 20).
在 2020-05-04, 卖了 15 个苹果 和 16 个桔子 (差异为 15 - 16 = -1).
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select a.sale_date, a.sold_num - b.sold_num as diff
from Sales a left join Sales b
on a.sale_date = b.sale_date 
where a.fruit = &#39;apples&#39; and b.fruit = &#39;oranges&#39;;
</code></pre>
<p><strong>自连接数据表</strong><br> 把 <code>Sales</code> 表取两份：一份叫 <code>a</code>，一份叫 <code>b</code>，然后通过 <code>a.sale_date = b.sale_date</code> 把同一天的苹果和橘子配对到一起。</p>
<p><strong>限定水果种类</strong><br> 在 <code>where</code> 子句里规定：<code>a.fruit = &#39;apples&#39;</code>，<code>b.fruit = &#39;oranges&#39;</code>，这样就保证 <code>a</code> 表只取苹果的销售数据，<code>b</code> 表只取橘子的销售数据。</p>
<p><strong>计算销售差值</strong><br> 在 <code>select</code> 里取出日期 (<code>a.sale_date</code>)、苹果销量 (<code>a.sold_num</code>)、橘子销量 (<code>b.sold_num</code>)，并且计算它们的差值 <code>a.sold_num - b.sold_num</code>，命名为 <code>diff</code>。</p>
<p><strong>方法二：行转列</strong></p>
<pre><code class="language-sql">
select sale_date, (apple-orange)as diff from(
    select sale_date, max(case when fruit = &#39;apples&#39; then sold_num else 0 end) as apple, max(case when fruit = &#39;oranges&#39; then sold_num else 0 end)as orange from Sales group by sale_date
    )t;
</code></pre>
<hr>
<h3 id="1699-两人之间的通话次数"><a href="#1699-两人之间的通话次数" class="headerlink" title="1699.两人之间的通话次数"></a>1699.两人之间的通话次数</h3><p>表： <code>Calls</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| from_id     | int     |
| to_id       | int     |
| duration    | int     |
+-------------+---------+
该表没有主键(具有唯一值的列)，它可能包含重复项。
该表包含 from_id 与 to_id 间的一次电话的时长。
from_id != to_id
</code></pre>
<p>编写解决方案，统计每一对用户 <code>(person1, person2)</code> 之间的通话次数和通话总时长，其中 <code>person1 &lt; person2</code> 。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>返回结果格式如下示例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Calls 表：
+---------+-------+----------+
| from_id | to_id | duration |
+---------+-------+----------+
| 1       | 2     | 59       |
| 2       | 1     | 11       |
| 1       | 3     | 20       |
| 3       | 4     | 100      |
| 3       | 4     | 200      |
| 3       | 4     | 200      |
| 4       | 3     | 499      |
+---------+-------+----------+
输出：
+---------+---------+------------+----------------+
| person1 | person2 | call_count | total_duration |
+---------+---------+------------+----------------+
| 1       | 2       | 2          | 70             |
| 1       | 3       | 1          | 20             |
| 3       | 4       | 4          | 999            |
+---------+---------+------------+----------------+
解释：
用户 1 和 2 打过 2 次电话，总时长为 70 (59 + 11)。
用户 1 和 3 打过 1 次电话，总时长为 20。
用户 3 和 4 打过 4 次电话，总时长为 999 (100 + 200 + 200 + 499)。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select a as person1, b as person2, sum(total_count) as call_count, sum(total) as total_duration from(
select from_id as a, to_id as b, count(*) as total_count, sum(duration) as total from Calls group by
from_id, to_id 
union all
select to_id as a, from_id as b, count(*) as total_count, sum(duration) as total from Calls group by
to_id, from_id
)t where a &lt; b group by a, b;
</code></pre>
<p><strong>正反向通话拆开统计</strong><br> 先用 <code>from_id → to_id</code> 分组统计每一对通话的次数和总时长，再用 <code>to_id → from_id</code> 反向统计。<br> 这样做的目的是把双方互相拨打的情况都纳入考虑。</p>
<p><strong><code>union all</code> 合并结果</strong><br> 把正向和反向的结果拼在一起，形成一张“对称”的结果集。<br> 此时，每一对用户 (person1, person2) 会出现两次：一条是正向统计，一条是反向统计。</p>
<p><strong>统一顺序并再次聚合</strong><br> 在外层查询里，用 <code>where a &lt; b</code> 保证只保留 <code>(小id, 大id)</code> 的组合，消除顺序带来的重复。<br> 然后再按 <code>(a, b)</code> 分组，用 <code>sum(total_count)</code> 和 <code>sum(total)</code> 汇总双方的通话次数和总时长。</p>
<hr>
<h3 id="1501-可以放心投资的国家"><a href="#1501-可以放心投资的国家" class="headerlink" title="1501.可以放心投资的国家"></a>1501.可以放心投资的国家</h3><p>表 <code>Person</code>:</p>
<pre><code>+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| id             | int     |
| name           | varchar |
| phone_number   | varchar |
+----------------+---------+
id 是该表具有唯一值的列.
该表每一行包含一个人的名字和电话号码.
电话号码的格式是:&#39;xxx-yyyyyyy&#39;, 其中 xxx 是国家码(3 个字符), yyyyyyy 是电话号码(7 个字符), x 和 y 都表示数字. 同时, 国家码和电话号码都可以包含前导 0.
</code></pre>
<p>表 <code>Country</code>:</p>
<pre><code>+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| name           | varchar |
| country_code   | varchar |
+----------------+---------+
country_code 是该表具有唯一值的列.
该表每一行包含国家名和国家码. country_code 的格式是&#39;xxx&#39;, x 是数字.
</code></pre>
<p>表 <code>Calls</code>:</p>
<pre><code>+-------------+------+
| Column Name | Type |
+-------------+------+
| caller_id   | int  |
| callee_id   | int  |
| duration    | int  |
+-------------+------+
该表无主键, 可能包含重复行.
每一行包含呼叫方 id, 被呼叫方 id 和以分钟为单位的通话时长. caller_id != callee_id
</code></pre>
<p>一家电信公司想要投资新的国家。该公司想要投资的国家是: 该国的平均通话时长要严格地大于全球平均通话时长。</p>
<p>写一个解决方案, 找到所有该公司可以投资的国家。</p>
<p>返回的结果表 <strong>无顺序要求</strong>。</p>
<p>结果格式如下例所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Person 表：
+----+----------+--------------+
| id | name     | phone_number |
+----+----------+--------------+
| 3  | Jonathan | 051-1234567  |
| 12 | Elvis    | 051-7654321  |
| 1  | Moncef   | 212-1234567  |
| 2  | Maroua   | 212-6523651  |
| 7  | Meir     | 972-1234567  |
| 9  | Rachel   | 972-0011100  |
+----+----------+--------------+
Country 表:
+----------+--------------+
| name     | country_code |
+----------+--------------+
| Peru     | 051          |
| Israel   | 972          |
| Morocco  | 212          |
| Germany  | 049          |
| Ethiopia | 251          |
+----------+--------------+
Calls 表:
+-----------+-----------+----------+
| caller_id | callee_id | duration |
+-----------+-----------+----------+
| 1         | 9         | 33       |
| 2         | 9         | 4        |
| 1         | 2         | 59       |
| 3         | 12        | 102      |
| 3         | 12        | 330      |
| 12        | 3         | 5        |
| 7         | 9         | 13       |
| 7         | 1         | 3        |
| 9         | 7         | 1        |
| 1         | 7         | 7        |
+-----------+-----------+----------+
输出：
+----------+
| country  |
+----------+
| Peru     |
+----------+
解释：
国家 Peru 的平均通话时长是 (102 + 102 + 330 + 330 + 5 + 5) / 6 = 145.666667
国家 Israel 的平均通话时长是 (33 + 4 + 13 + 13 + 3 + 1 + 1 + 7) / 8 = 9.37500
国家 Morocco 的平均通话时长是 (33 + 4 + 59 + 59 + 3 + 7) / 6 = 27.5000 
全球平均通话时长 = (2 * (33 + 4 + 59 + 102 + 330 + 5 + 13 + 3 + 1 + 7)) / 20 = 55.70000
所以, Peru 是唯一的平均通话时长大于全球平均通话时长的国家, 也是唯一的推荐投资的国家.
</code></pre>
<p><strong>解答：</strong></p>
<p><strong>和上一题一个思路，将coller_id和collee_id通过union all转化到同一个表的同一列</strong></p>
<p>一个表（Calls）中出现两列（caller_id 、callee_id）都是同属一个表（Person）里的属性，用join+union即可全部归纳</p>
<pre><code class="language-sql">with base as(
    select c1.caller_id as id, c1.duration as phonetime, p1.phone_number as number from Calls c1 join Person p1 on c1.caller_id = p1.id 
    union all
    select c2.callee_id as id, c2.duration as phonetime, p2.phone_number as number from Calls c2 join Person p2 on c2.callee_id = p2.id 
),
seq as(
    select a.id, a.phonetime, b.name as country_name from base a join Country b on substring(a.number, 1, 3) = b.country_code 
),
country_avg as (
    select country_name, avg(phonetime) as avg_time from seq group by country_name
),
global_avg as (
    select avg(phonetime) as avg_global from seq 
)
select country_name as country from country_avg where avg_time &gt; (
    select avg_global from global_avg
</code></pre>
<ol>
<li><strong>提取国家代码</strong>：从<code>Person</code>表中提取每个用户的国家代码（电话号码的前三个字符）。</li>
<li><strong>计算每个通话的国家</strong>：对于<code>Calls</code>表中的每个通话，无论是呼叫者还是被呼叫者，都需要确定其国家代码，从而将通话时长分配给相应的国家。</li>
<li><strong>计算每个国家的平均通话时长</strong>：汇总每个国家的所有通话时长，计算其平均值。</li>
<li><strong>计算全球平均通话时长</strong>：汇总所有通话的通话时长，计算全球平均值。</li>
<li><strong>比较并筛选国家</strong>：筛选出那些平均通话时长严格大于全球平均通话时长的国家。</li>
</ol>
<hr>
<h3 id="1264-页面描述"><a href="#1264-页面描述" class="headerlink" title="1264.页面描述"></a>1264.页面描述</h3><p>朋友关系列表： <code>Friendship</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user1_id      | int     |
| user2_id      | int     |
+---------------+---------+
(user1_id, user2_id) 是这张表具有唯一值的列的组合。
这张表的每一行代表着 user1_id 和 user2_id 之间存在着朋友关系。
</code></pre>
<p>喜欢列表： <code>Likes</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| user_id     | int     |
| page_id     | int     |
+-------------+---------+
(user_id, page_id) 是这张表具有唯一值的列的组合。
这张表的每一行代表着 user_id 喜欢 page_id。
</code></pre>
<p>编写解决方案，向<code>user_id</code> &#x3D; 1 的用户，推荐其朋友们喜欢的页面。不要推荐该用户已经喜欢的页面。</p>
<p>以 <strong>任意顺序</strong> 返回结果，其中不应当包含重复项。</p>
<p>返回结果的格式如下例所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Friendship table:
+----------+----------+
| user1_id | user2_id |
+----------+----------+
| 1        | 2        |
| 1        | 3        |
| 1        | 4        |
| 2        | 3        |
| 2        | 4        |
| 2        | 5        |
| 6        | 1        |
+----------+----------+
 
Likes table:
+---------+---------+
| user_id | page_id |
+---------+---------+
| 1       | 88      |
| 2       | 23      |
| 3       | 24      |
| 4       | 56      |
| 5       | 11      |
| 6       | 33      |
| 2       | 77      |
| 3       | 77      |
| 6       | 88      |
+---------+---------+

输出：
+------------------+
| recommended_page |
+------------------+
| 23               |
| 24               |
| 56               |
| 33               |
| 77               |
+------------------+
解释：
用户1 同 用户2, 3, 4, 6 是朋友关系。
推荐页面为： 页面23 来自于 用户2, 页面24 来自于 用户3, 页面56 来自于 用户3 以及 页面33 来自于 用户6。
页面77 同时被 用户2 和 用户3 推荐。
页面88 没有被推荐，因为 用户1 已经喜欢了它。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">with base as(
    select case when user1_id = 1 then user2_id 
    when user2_id = 1 then user1_id else null end as friend from Friendship
),
seq as(
    select distinct a.page_id from Likes a join base b on a.user_id = b.friend where b.friend is not null
)
select page_id as recommended_page from seq a where not exists (
    select b.page_id from Likes b where b.user_id = 1 and a.page_id = b.page_id
);
</code></pre>
<p>如果等值子查询会返回null，则需要使用not exists+相关子查询</p>
<hr>
<h3 id="608-树节点"><a href="#608-树节点" class="headerlink" title="608.树节点"></a>608.树节点</h3><p>表：<code>Tree</code></p>
<pre><code>+-------------+------+
| Column Name | Type |
+-------------+------+
| id          | int  |
| p_id        | int  |
+-------------+------+
id 是该表中具有唯一值的列。
该表的每行包含树中节点的 id 及其父节点的 id 信息。
给定的结构总是一个有效的树。
</code></pre>
<p>树中的每个节点可以是以下三种类型之一：</p>
<ul>
<li><strong>“Leaf”</strong>：节点是叶子节点。</li>
<li><strong>“Root”</strong>：节点是树的根节点。</li>
<li><strong>“lnner”</strong>：节点既不是叶子节点也不是根节点。</li>
</ul>
<p>编写一个解决方案来报告树中每个节点的类型。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Tree table:
+----+------+
| id | p_id |
+----+------+
| 1  | null |
| 2  | 1    |
| 3  | 1    |
| 4  | 2    |
| 5  | 2    |
+----+------+
输出：
+----+-------+
| id | type  |
+----+-------+
| 1  | Root  |
| 2  | Inner |
| 3  | Leaf  |
| 4  | Leaf  |
| 5  | Leaf  |
+----+-------+
解释：
节点 1 是根节点，因为它的父节点为空，并且它有子节点 2 和 3。
节点 2 是一个内部节点，因为它有父节点 1 和子节点 4 和 5。
节点 3、4 和 5 是叶子节点，因为它们有父节点而没有子节点。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：
Tree table:
+----+------+
| id | p_id |
+----+------+
| 1  | null |
+----+------+
输出：
+----+-------+
| id | type  |
+----+-------+
| 1  | Root  |
+----+-------+
解释：如果树中只有一个节点，则只需要输出其根属性。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">
select id, case when p_id is null then &#39;Root&#39; 
when id in (select p_id from Tree where p_id is not null) then &#39;Inner&#39;
else &#39;Leaf&#39; end as type from Tree;
</code></pre>
<hr>
<h3 id="534-游戏玩法分析"><a href="#534-游戏玩法分析" class="headerlink" title="534.游戏玩法分析 |||"></a>534.游戏玩法分析 |||</h3><p>表：<code>Activity</code></p>
<pre><code>+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
（player_id，event_date）是此表的主键（具有唯一值的列）。
这张表显示了某些游戏的玩家的活动情况。
每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0 ）。
</code></pre>
<p>编写一个解决方案，同时报告每组玩家和日期，以及玩家到 <strong>目前为止</strong> 玩了多少游戏。也就是说，玩家在该日期之前所玩的游戏总数。详细情况请查看示例。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-05-02 | 6            |
| 1         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+
输出：
+-----------+------------+---------------------+
| player_id | event_date | games_played_so_far |
+-----------+------------+---------------------+
| 1         | 2016-03-01 | 5                   |
| 1         | 2016-05-02 | 11                  |
| 1         | 2017-06-25 | 12                  |
| 3         | 2016-03-02 | 0                   |
| 3         | 2018-07-03 | 5                   |
+-----------+------------+---------------------+
解释：
对于 ID 为 1 的玩家，2016-05-02 共玩了 5+6=11 个游戏，2017-06-25 共玩了 5+6+1=12 个游戏。
对于 ID 为 3 的玩家，2018-07-03 共玩了 0+5=5 个游戏。
请注意，对于每个玩家，我们只关心玩家的登录日期。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select player_id, event_date, sum(games_played)over (partition by player_id order by event_date)as games_played_so_far from Activity;
</code></pre>
<hr>
<h3 id="1783-大满贯数量"><a href="#1783-大满贯数量" class="headerlink" title="1783.大满贯数量"></a>1783.大满贯数量</h3><p>表：<code>Players</code></p>
<pre><code>+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| player_id      | int     |
| player_name    | varchar |
+----------------+---------+
player_id 是这个表的主键（具有唯一值的列）
这个表的每一行给出一个网球运动员的 ID 和 姓名
</code></pre>
<p>表：<code>Championships</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| year          | int     |
| Wimbledon     | int     |
| Fr_open       | int     |
| US_open       | int     |
| Au_open       | int     |
+---------------+---------+
year 是这个表的主键（具有唯一值的列）
该表的每一行都包含在每场大满贯网球比赛中赢得比赛的球员的 ID
</code></pre>
<p>编写解决方案，找出每一个球员赢得大满贯比赛的次数。结果不包含没有赢得比赛的球员的ID 。</p>
<p>结果集 <strong>无顺序要求</strong> 。</p>
<p>结果的格式，如下所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Players 表：
+-----------+-------------+
| player_id | player_name |
+-----------+-------------+
| 1         | Nadal       |
| 2         | Federer     |
| 3         | Novak       |
+-----------+-------------+
Championships 表：
+------+-----------+---------+---------+---------+
| year | Wimbledon | Fr_open | US_open | Au_open |
+------+-----------+---------+---------+---------+
| 2018 | 1         | 1       | 1       | 1       |
| 2019 | 1         | 1       | 2       | 2       |
| 2020 | 2         | 1       | 2       | 2       |
+------+-----------+---------+---------+---------+
输出：
+-----------+-------------+-------------------+
| player_id | player_name | grand_slams_count |
+-----------+-------------+-------------------+
| 2         | Federer     | 5                 |
| 1         | Nadal       | 7                 |
+-----------+-------------+-------------------+
解释：
Player 1 (Nadal) 获得了 7 次大满贯：其中温网 2 次(2018, 2019), 法国公开赛 3 次 (2018, 2019, 2020), 美国公开赛 1 次 (2018)以及澳网公开赛 1 次 (2018) 。
Player 2 (Federer) 获得了 5 次大满贯：其中温网 1 次 (2020), 美国公开赛 2 次 (2019, 2020) 以及澳网公开赛 2 次 (2019, 2020) 。
Player 3 (Novak)  没有赢得，因此不包含在结果集中。
</code></pre>
<p><strong>解答：</strong></p>
<p>我用的是列转行的思路进行解答，把比赛名这几列转为新列competition的不同行，把不同比赛的获胜id转为player_id的不同行。</p>
<pre><code class="language-sql">select a.player_id , a.player_name, count(b.player_id) as grand_slams_count from Players a right join(
select Wimbledon as player_id, &#39;Wimbledon&#39; as competition from Championships  
union all
select Fr_open as player_id, &#39;Fr_open&#39; as competition from Championships  
union all
select US_open as player_id, &#39;US_open&#39; as competition from Championships  
union all
select Au_open as player_id, &#39;Au_open&#39; as competition from Championships )b 
on a.player_id = b.player_id group by b.player_id;
</code></pre>
<hr>
<h3 id="1747-应该被禁止的Leetflex账户"><a href="#1747-应该被禁止的Leetflex账户" class="headerlink" title="1747..应该被禁止的Leetflex账户"></a>1747..应该被禁止的Leetflex账户</h3><p>表: <code>LogInfo</code></p>
<pre><code>+-------------+----------+
| Column Name | Type     |
+-------------+----------+
| account_id  | int      |
| ip_address  | int      |
| login       | datetime |
| logout      | datetime |
+-------------+----------+
该表可能包含重复项。
该表包含有关Leetflex帐户的登录和注销日期的信息。 它还包含了该账户用于登录和注销的网络地址的信息。
题目确保每一个注销时间都在登录时间之后。
</code></pre>
<p>编写解决方案，查找那些应该被禁止的Leetflex帐户编号 <code>account_id</code> 。 如果某个帐户在某一时刻从两个不同的网络地址登录了，则这个帐户应该被禁止。</p>
<p>可以以 <strong>任何顺序</strong> 返回结果。</p>
<p>查询结果格式如下例所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
LogInfo table:
+------------+------------+---------------------+---------------------+
| account_id | ip_address | login               | logout              |
+------------+------------+---------------------+---------------------+
| 1          | 1          | 2021-02-01 09:00:00 | 2021-02-01 09:30:00 |
| 1          | 2          | 2021-02-01 08:00:00 | 2021-02-01 11:30:00 |
| 2          | 6          | 2021-02-01 20:30:00 | 2021-02-01 22:00:00 |
| 2          | 7          | 2021-02-02 20:30:00 | 2021-02-02 22:00:00 |
| 3          | 9          | 2021-02-01 16:00:00 | 2021-02-01 16:59:59 |
| 3          | 13         | 2021-02-01 17:00:00 | 2021-02-01 17:59:59 |
| 4          | 10         | 2021-02-01 16:00:00 | 2021-02-01 17:00:00 |
| 4          | 11         | 2021-02-01 17:00:00 | 2021-02-01 17:59:59 |
+------------+------------+---------------------+---------------------+
输出：
+------------+
| account_id |
+------------+
| 1          |
| 4          |
+------------+
解释：
Account ID 1 --&gt; 该账户从 &quot;2021-02-01 09:00:00&quot; 到 &quot;2021-02-01 09:30:00&quot; 在两个不同的网络地址(1 and 2)上激活了。它应该被禁止.
Account ID 2 --&gt; 该账户在两个不同的网络地址 (6, 7) 激活了，但在不同的时间上.
Account ID 3 --&gt; 该账户在两个不同的网络地址 (9, 13) 激活了，虽然是同一天，但时间上没有交集.
Account ID 4 --&gt; 该账户从 &quot;2021-02-01 17:00:00&quot; 到 &quot;2021-02-01 17:00:00&quot; 在两个不同的网络地址 (10 and 11)上激活了。它应该被禁止.
</code></pre>
<p><strong>解答：</strong></p>
<p>同一个id的不同列数值进行对比——&gt;使用自连接。</p>
<p>注意：使用join时on的条件越少效率越高。</p>
<pre><code class="language-sql">select account_id from (
select max(case when b.login &gt; a.login and b.login &lt;= a.logout then a.account_id else 0 end) as account_id
from LogInfo a join LogInfo b on a.account_id = b.account_id where a.ip_address != b.ip_address group by a.account_id)t where account_id &gt; 0;
</code></pre>
<p>若把a.ip_address !&#x3D; b.ip_address写到on中则会报超时</p>
<pre><code class="language-sql">from LogInfo a join LogInfo b on a.account_id = b.account_id and a.ip_address != b.ip_address group by a.account_id)t where account_id &gt; 0;
</code></pre>
<hr>
<h3 id="184-部门工资最高的员工"><a href="#184-部门工资最高的员工" class="headerlink" title="184.部门工资最高的员工"></a>184.部门工资最高的员工</h3><p>表： <code>Employee</code></p>
<pre><code>+--------------+---------+
| 列名          | 类型    |
+--------------+---------+
| id           | int     |
| name         | varchar |
| salary       | int     |
| departmentId | int     |
+--------------+---------+
在 SQL 中，id是此表的主键。
departmentId 是 Department 表中 id 的外键（在 Pandas 中称为 join key）。
此表的每一行都表示员工的 id、姓名和工资。它还包含他们所在部门的 id。
</code></pre>
<p>表： <code>Department</code></p>
<pre><code>+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| id          | int     |
| name        | varchar |
+-------------+---------+
在 SQL 中，id 是此表的主键列。
此表的每一行都表示一个部门的 d 及其名称。
</code></pre>
<p>查找出每个部门中薪资最高的员工。<br>按 <strong>任意顺序</strong> 返回结果表。<br>查询结果格式如下例所示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Employee 表:
+----+-------+--------+--------------+
| id | name  | salary | departmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Jim   | 90000  | 1            |
| 3  | Henry | 80000  | 2            |
| 4  | Sam   | 60000  | 2            |
| 5  | Max   | 90000  | 1            |
+----+-------+--------+--------------+
Department 表:
+----+-------+
| id | name  |
+----+-------+
| 1  | IT    |
| 2  | Sales |
+----+-------+
输出：
+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Jim      | 90000  |
| Sales      | Henry    | 80000  |
| IT         | Max      | 90000  |
+------------+----------+--------+
解释：Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select b.name as Department, a.name as Employee, a.salary as Salary from (select *, RANK() over(partition by departmentId order by salary DESC) as rk from Employee) a join Department b on a.departmentId = b.id where a.rk = 1;
</code></pre>
<hr>
<h3 id="1549-每件商品的最新订单"><a href="#1549-每件商品的最新订单" class="headerlink" title="1549.每件商品的最新订单"></a>1549.每件商品的最新订单</h3><p>表: <code>Customers</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| customer_id   | int     |
| name          | varchar |
+---------------+---------+
customer_id 是该表主键.
该表包含消费者的信息.
</code></pre>
<p>表: <code>Orders</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| customer_id   | int     |
| product_id    | int     |
+---------------+---------+
order_id 是该表主键.
该表包含消费者customer_id产生的订单.
不会有商品被相同的用户在一天内下单超过一次.
</code></pre>
<p>表: <code>Products</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| product_name  | varchar |
| price         | int     |
+---------------+---------+
product_id 是该表主键.
该表包含所有商品的信息.
</code></pre>
<p>写一个解决方案, 找到每件商品的最新订单(可能有多个).</p>
<p>返回的结果以 <code>product_name</code> <strong>升序排列</strong>, 如果有排序相同, 再以 <code>product_id</code> <strong>升序</strong>排列. 如果还有排序相同, 再以 <code>order_id</code> <strong>升序</strong>排列.</p>
<p>查询结果格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入:
Customers表：
+-------------+-----------+
| customer_id | name      |
+-------------+-----------+
| 1           | Winston   |
| 2           | Jonathan  |
| 3           | Annabelle |
| 4           | Marwan    |
| 5           | Khaled    |
+-------------+-----------+
Orders表：
+----------+------------+-------------+------------+
| order_id | order_date | customer_id | product_id |
+----------+------------+-------------+------------+
| 1        | 2020-07-31 | 1           | 1          |
| 2        | 2020-07-30 | 2           | 2          |
| 3        | 2020-08-29 | 3           | 3          |
| 4        | 2020-07-29 | 4           | 1          |
| 5        | 2020-06-10 | 1           | 2          |
| 6        | 2020-08-01 | 2           | 1          |
| 7        | 2020-08-01 | 3           | 1          |
| 8        | 2020-08-03 | 1           | 2          |
| 9        | 2020-08-07 | 2           | 3          |
| 10       | 2020-07-15 | 1           | 2          |
+----------+------------+-------------+------------+
Products表：
+------------+--------------+-------+
| product_id | product_name | price |
+------------+--------------+-------+
| 1          | keyboard     | 120   |
| 2          | mouse        | 80    |
| 3          | screen       | 600   |
| 4          | hard disk    | 450   |
+------------+--------------+-------+
输出：
+--------------+------------+----------+------------+
| product_name | product_id | order_id | order_date |
+--------------+------------+----------+------------+
| keyboard     | 1          | 6        | 2020-08-01 |
| keyboard     | 1          | 7        | 2020-08-01 |
| mouse        | 2          | 8        | 2020-08-03 |
| screen       | 3          | 3        | 2020-08-29 |
+--------------+------------+----------+------------+
解释：
keyboard 的最新订单在2020-08-01, 在这天有两次下单.
mouse 的最新订单在2020-08-03, 在这天只有一次下单.
screen 的最新订单在2020-08-29, 在这天只有一次下单.
hard disk 没有被下单, 我们不把它包含在结果表中.
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select a.product_name, a.product_id, b.order_id, b.order_date from Products a left join (select order_date, order_id, product_id, max(order_date) over(partition by product_id) as max_order from Orders)b on a.product_id = b.product_id where b.order_date = b.max_order order by product_name, product_id, order_id;
</code></pre>
<hr>
<h3 id="1532-最近的三笔订单"><a href="#1532-最近的三笔订单" class="headerlink" title="1532.最近的三笔订单"></a>1532.最近的三笔订单</h3><p>表：<code>Customers</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| customer_id   | int     |
| name          | varchar |
+---------------+---------+
customer_id 是该表具有唯一值的列
该表包含消费者的信息
</code></pre>
<p>表：<code>Orders</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| customer_id   | int     |
| cost          | int     |
+---------------+---------+
order_id 是该表具有唯一值的列
该表包含 id 为 customer_id 的消费者的订单信息
每一个消费者 每天一笔订单
</code></pre>
<p>写一个解决方案，找到每个用户的最近三笔订单。如果用户的订单少于 3 笔，则返回他的全部订单。</p>
<p>返回的结果按照 <code>customer_name</code> <strong>升序</strong> 排列。如果有相同的排名，则按照 <code>customer_id</code> <strong>升序</strong> 排列。如果排名还有相同，则按照 <code>order_date</code> <strong>降序</strong> 排列。</p>
<p>结果格式如下例所示：</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
Customers
+-------------+-----------+
| customer_id | name      |
+-------------+-----------+
| 1           | Winston   |
| 2           | Jonathan  |
| 3           | Annabelle |
| 4           | Marwan    |
| 5           | Khaled    |
+-------------+-----------+

Orders
+----------+------------+-------------+------+
| order_id | order_date | customer_id | cost |
+----------+------------+-------------+------+
| 1        | 2020-07-31 | 1           | 30   |
| 2        | 2020-07-30 | 2           | 40   |
| 3        | 2020-07-31 | 3           | 70   |
| 4        | 2020-07-29 | 4           | 100  |
| 5        | 2020-06-10 | 1           | 1010 |
| 6        | 2020-08-01 | 2           | 102  |
| 7        | 2020-08-01 | 3           | 111  |
| 8        | 2020-08-03 | 1           | 99   |
| 9        | 2020-08-07 | 2           | 32   |
| 10       | 2020-07-15 | 1           | 2    |
+----------+------------+-------------+------+
输出：
+---------------+-------------+----------+------------+
| customer_name | customer_id | order_id | order_date |
+---------------+-------------+----------+------------+
| Annabelle     | 3           | 7        | 2020-08-01 |
| Annabelle     | 3           | 3        | 2020-07-31 |
| Jonathan      | 2           | 9        | 2020-08-07 |
| Jonathan      | 2           | 6        | 2020-08-01 |
| Jonathan      | 2           | 2        | 2020-07-30 |
| Marwan        | 4           | 4        | 2020-07-29 |
| Winston       | 1           | 8        | 2020-08-03 |
| Winston       | 1           | 1        | 2020-07-31 |
| Winston       | 1           | 10       | 2020-07-15 |
+---------------+-------------+----------+------------+
解释：
Winston 有 4 笔订单, 排除了 &quot;2020-06-10&quot; 的订单, 因为它是最老的订单。
Annabelle 只有 2 笔订单, 全部返回。
Jonathan 恰好有 3 笔订单。
Marwan 只有 1 笔订单。
结果表我们按照 customer_name 升序排列，customer_id 升序排列，order_date 降序排列。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select a.name as customer_name, a.customer_id, b.order_id, b.order_date from Customers a left join (
select *, rank() over(partition by customer_id order by order_date DESC)as rk from Orders )b on 
a.customer_id = b.customer_id where rk &lt;= 3 order by customer_name, customer_id, order_date DESC;
</code></pre>
<hr>
<h3 id="1831-每天的最大交易"><a href="#1831-每天的最大交易" class="headerlink" title="1831.每天的最大交易"></a>1831.每天的最大交易</h3><p>表：<code>Transactions</code></p>
<pre><code>+----------------+----------+
| Column Name    | Type     |
+----------------+----------+
| transaction_id | int      |
| day            | datetime |
| amount         | int      |
+----------------+----------+
transaction_id 是该表具有唯一值的列。
每行包括了该次交易的信息。
</code></pre>
<p>编写一个解决方案，报告每天交易金额 <code>amount</code> <strong>最大</strong> 的交易 ID 。如果一天中有多个这样的交易，返回这些交易的 ID 。</p>
<p>返回结果根据 <code>transaction_id</code> <strong>升序排列</strong>。</p>
<p>返回格式如下示例所示：</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Transactions table:
+----------------+--------------------+--------+
| transaction_id | day                | amount |
+----------------+--------------------+--------+
| 8              | 2021-4-3 15:57:28  | 57     |
| 9              | 2021-4-28 08:47:25 | 21     |
| 1              | 2021-4-29 13:28:30 | 58     |
| 5              | 2021-4-28 16:39:59 | 40     |
| 6              | 2021-4-29 23:39:28 | 58     |
+----------------+--------------------+--------+
输出：
+----------------+
| transaction_id |
+----------------+
| 1              |
| 5              |
| 6              |
| 8              |
+----------------+
解释：
&quot;2021-4-3&quot;  --&gt; 有一个 id 是 8 的交易，因此，把它加入结果表。 
&quot;2021-4-28&quot; --&gt; 有两个交易，id 是 5 和 9 ，交易 5 的金额是 40 ，而交易 9 的数量是 21 。只需要将交易 5 加入结果表，因为它是当天金额最大的交易。
&quot;2021-4-29&quot; --&gt; 有两个交易，id 是 1 和 6 ，这两个交易的金额都是 58 ，因此需要把它们都写入结果表。
最后，把交易 id 按照升序排列。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">select transaction_id from (
select *, rank() over(partition by DAY(day) order by amount DESC) as rk from Transactions)t 
where rk = 1 order by transaction_id;
</code></pre>
<hr>
<h3 id="1285-找到连续区间的开始和结束数字"><a href="#1285-找到连续区间的开始和结束数字" class="headerlink" title="1285.找到连续区间的开始和结束数字"></a>1285.找到连续区间的开始和结束数字</h3><p>表：<code>Logs</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| log_id        | int     |
+---------------+---------+
id 是上表具有唯一值的列。
上表的每一行包含日志表中的一个 ID。
</code></pre>
<p>编写解决方案，得到 <code>Logs</code> 表中的连续区间的开始数字和结束数字。</p>
<p>返回结果表按照 <code>start_id</code> 排序。</p>
<p>结果格式如下面的例子。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Logs 表：
+------------+
| log_id     |
+------------+
| 1          |
| 2          |
| 3          |
| 7          |
| 8          |
| 10         |
+------------+
输出：
+------------+--------------+
| start_id   | end_id       |
+------------+--------------+
| 1          | 3            |
| 7          | 8            |
| 10         | 10           |
+------------+--------------+
解释：
结果表应包含 Logs 表中的所有区间。
从 1 到 3 在表中。
从 4 到 6 不在表中。
从 7 到 8 在表中。
9 不在表中。
10 在表中。
</code></pre>
<p><strong>解答：</strong></p>
<p>连续区间：用row_number构造排序数字rk，用log_id减去rk得差值diff，相同差值diff代表同一连续区间</p>
<pre><code class="language-sql">with base as(
    select *, row_number() over (order by log_id) as rk from Logs 
),
seq as(
    select log_id, log_id - rk as diff from base 
)
select distinct min(log_id)over (partition by diff) as start_id, max(log_id) over(partition by diff)as end_id from
seq; 
</code></pre>
<hr>
<h3 id="1596-每位顾客最经常订购的商品（易）"><a href="#1596-每位顾客最经常订购的商品（易）" class="headerlink" title="1596. 每位顾客最经常订购的商品（易）"></a>1596. 每位顾客最经常订购的商品（易）</h3><p>表：<code>Customers</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| customer_id   | int     |
| name          | varchar |
+---------------+---------+
customer_id 是该表具有唯一值的列
该表包含所有顾客的信息
</code></pre>
<p>表：<code>Orders</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| customer_id   | int     |
| product_id    | int     |
+---------------+---------+
order_id 是该表具有唯一值的列
该表包含顾客 customer_id 的订单信息
没有顾客会在一天内订购相同的商品 多于一次
</code></pre>
<p>表：<code>Products</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| product_name  | varchar |
| price         | int     |
+---------------+---------+
product_id 是该表具有唯一值的列
该表包含了所有商品的信息
</code></pre>
<p>写一个解决方案，找到每一个顾客最经常订购的商品。</p>
<p>结果表单应该有每一位至少下过一次单的顾客 <code>customer_id</code> , 他最经常订购的商品的 <code>product_id</code> 和 <code>product_name</code>。</p>
<p>返回结果 <strong>没有顺序要求</strong>。</p>
<p>查询结果格式如下例所示。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Customers表：
+-------------+-------+
| customer_id | name  |
+-------------+-------+
| 1           | Alice |
| 2           | Bob   |
| 3           | Tom   |
| 4           | Jerry |
| 5           | John  |
+-------------+-------+
Orders表：
+----------+------------+-------------+------------+
| order_id | order_date | customer_id | product_id |
+----------+------------+-------------+------------+
| 1        | 2020-07-31 | 1           | 1          |
| 2        | 2020-07-30 | 2           | 2          |
| 3        | 2020-08-29 | 3           | 3          |
| 4        | 2020-07-29 | 4           | 1          |
| 5        | 2020-06-10 | 1           | 2          |
| 6        | 2020-08-01 | 2           | 1          |
| 7        | 2020-08-01 | 3           | 3          |
| 8        | 2020-08-03 | 1           | 2          |
| 9        | 2020-08-07 | 2           | 3          |
| 10       | 2020-07-15 | 1           | 2          |
+----------+------------+-------------+------------+
Products表：
+------------+--------------+-------+
| product_id | product_name | price |
+------------+--------------+-------+
| 1          | keyboard     | 120   |
| 2          | mouse        | 80    |
| 3          | screen       | 600   |
| 4          | hard disk    | 450   |
+------------+--------------+-------+
输出：
+-------------+------------+--------------+
| customer_id | product_id | product_name |
+-------------+------------+--------------+
| 1           | 2          | mouse        |
| 2           | 1          | keyboard     |
| 2           | 2          | mouse        |
| 2           | 3          | screen       |
| 3           | 3          | screen       |
| 4           | 1          | keyboard     |
+-------------+------------+--------------+
解释：
Alice (customer 1) 三次订购鼠标, 一次订购键盘, 所以鼠标是 Alice 最经常订购的商品.
Bob (customer 2) 一次订购键盘, 一次订购鼠标, 一次订购显示器, 所以这些都是 Bob 最经常订购的商品.
Tom (customer 3) 只两次订购显示器, 所以显示器是 Tom 最经常订购的商品.
Jerry (customer 4) 只一次订购键盘, 所以键盘是 Jerry 最经常订购的商品.
John (customer 5) 没有订购过商品, 所以我们并没有把 John 包含在结果表中.
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">
with base as(
    select customer_id, product_id, count(*) as ct from Orders group by customer_id, product_id
),
seq as(
    select *, rank() over (partition by customer_id order by ct DESC) as rk from base 
)
select a.customer_id, a.product_id, b.product_name from seq a left join Products b on a.product_id = b.product_id where rk = 1;
</code></pre>
<hr>
<h3 id="1709-访问日期之间最大的空档期"><a href="#1709-访问日期之间最大的空档期" class="headerlink" title="1709. 访问日期之间最大的空档期"></a>1709. 访问日期之间最大的空档期</h3><p>表： <code>UserVisits</code></p>
<pre><code>+-------------+------+
| Column Name | Type |
+-------------+------+
| user_id     | int  |
| visit_date  | date |
+-------------+------+
该表没有主键，它可能有重复的行
该表包含用户访问某特定零售商的日期日志。
</code></pre>
<p>假设今天的日期是 <code>&#39;2021-1-1&#39;</code> 。</p>
<p>编写解决方案，对于每个 <code>user_id</code> ，求出每次访问及其下一个访问（若该次访问是最后一次，则为今天）之间最大的空档期天数 <code>window</code> 。</p>
<p>返回结果表，按用户编号 <code>user_id</code> 排序。</p>
<p>结果格式如下示例所示：</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
UserVisits 表：
+---------+------------+
| user_id | visit_date |
+---------+------------+
| 1       | 2020-11-28 |
| 1       | 2020-10-20 |
| 1       | 2020-12-3  |
| 2       | 2020-10-5  |
| 2       | 2020-12-9  |
| 3       | 2020-11-11 |
+---------+------------+
输出：
+---------+---------------+
| user_id | biggest_window|
+---------+---------------+
| 1       | 39            |
| 2       | 65            |
| 3       | 51            |
+---------+---------------+
解释：
对于第一个用户，问题中的空档期在以下日期之间：
    - 2020-10-20 至 2020-11-28 ，共计 39 天。
    - 2020-11-28 至 2020-12-3 ，共计 5 天。
    - 2020-12-3 至 2021-1-1 ，共计 29 天。
由此得出，最大的空档期为 39 天。
对于第二个用户，问题中的空档期在以下日期之间：
    - 2020-10-5 至 2020-12-9 ，共计 65 天。
    - 2020-12-9 至 2021-1-1 ，共计 23 天。
由此得出，最大的空档期为 65 天。
对于第三个用户，问题中的唯一空档期在 2020-11-11 至 2021-1-1 之间，共计 51 天。
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">with base as(
    select user_id, visit_date, IFNULL(lead(visit_date, 1) over (partition by user_id order by visit_date), &#39;2021-1-1&#39;)as next_date from UserVisits 
),
seq as (
    select *, datediff(next_date, visit_date) as diff from base 
)
select distinct user_id, diff as biggest_window from (
    select user_id, diff, max(diff) over(partition by user_id) as mx_diff from seq)t where diff = mx_diff;
</code></pre>
<hr>
<h3 id="1270-向公司CEO汇报工作的所有人"><a href="#1270-向公司CEO汇报工作的所有人" class="headerlink" title="1270. 向公司CEO汇报工作的所有人"></a>1270. 向公司CEO汇报工作的所有人</h3><p>员工表：<code>Employees</code></p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| employee_id   | int     |
| employee_name | varchar |
| manager_id    | int     |
+---------------+---------+
employee_id 是这个表具有唯一值的列。
这个表中每一行中，employee_id 表示职工的 ID，employee_name 表示职工的名字，manager_id 表示该职工汇报工作的直线经理。
这个公司 CEO 是 employee_id = 1 的人。
</code></pre>
<p>编写解决方案，找出所有直接或间接向公司 CEO 汇报工作的职工的 <code>employee_id</code> 。</p>
<p>由于公司规模较小，经理之间的间接关系 <strong>不超过 3 个经理</strong> 。</p>
<p>可以以 <strong>任何顺序</strong> 返回无重复项的结果。</p>
<p>返回结果示例如下。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
Employees table:
+-------------+---------------+------------+
| employee_id | employee_name | manager_id |
+-------------+---------------+------------+
| 1           | Boss          | 1          |
| 3           | Alice         | 3          |
| 2           | Bob           | 1          |
| 4           | Daniel        | 2          |
| 7           | Luis          | 4          |
| 8           | Jhon          | 3          |
| 9           | Angela        | 8          |
| 77          | Robert        | 1          |
+-------------+---------------+------------+
输出：
+-------------+
| employee_id |
+-------------+
| 2           |
| 77          |
| 4           |
| 7           |
+-------------+
解释：
公司 CEO 的 employee_id 是 1.
employee_id 是 2 和 77 的职员直接汇报给公司 CEO。
employee_id 是 4 的职员间接汇报给公司 CEO 4 --&gt; 2 --&gt; 1 。
employee_id 是 7 的职员间接汇报给公司 CEO 7 --&gt; 4 --&gt; 2 --&gt; 1 。
employee_id 是 3, 8 ，9 的职员不会直接或间接的汇报给公司 CEO。 
</code></pre>
<p><strong>解答：</strong></p>
<pre><code class="language-sql">with base1 as (
    select employee_id from Employees where manager_id = 1 and employee_id != 1
),
base as(
    select a.employee_id from Employees a join base1 b on a.manager_id = b.employee_id
)
select c.employee_id from Employees c join base d on c.manager_id = d.employee_id
union all 
select * from base
union all 
select * from base1;
</code></pre>
<p>补充：</p>
<p>将null转化为0——&gt;IFNULL(a.column, 0)</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Leetcode/" style="color: #03a9f4">Leetcode</a>
        </span>
        
    </div>
    <a href="/2021/09/09/Leetcode%20%20sql%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%952/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <a class="page-num" href="/">
        <i class="fa-solid fa-caret-left fa-fw"></i>
    </a>
    <a class="page-num" href="/">1</a>
    <span class="page-omit">...</span>
    
    <span class="current">2</span>
    
    
    
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/pic.jpg" alt="avatar" />
        </div>
        <div class="name">KING BOB</div>
        <div class="description">
            <p>Description<br>…</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 KING!BOB!
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;KING BOB
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    <canvas
    id="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>
    <canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>
    
<!-- hexo injector body_end start --><script data-pjax src="https://unpkg.com/oh-my-live2d"></script><script>const oml2d = OML2D.loadOml2d({dockedPosition:"right",mobileDisplay:true,models:[{"path":"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","mobilePosition":[-10,23],"mobileScale":0.1,"mobileStageStyle":{"width":180,"height":166},"motionPreloadStrategy":"IDLE","position":[-10,35],"scale":0.15,"stageStyle":{"width":250,"height":250}},{"path":"https://unpkg.com/live2d-widget-model-koharu@1.0.5/assets/koharu.model.json","scale":0.12,"position":[0,0],"stageStyle":{"width":250},"mobileScale":0.08,"mobilePosition":[0,0],"mobileStageStyle":{"width":180}},{"path":"https://unpkg.com/live2d-widget-model-haruto@1.0.5/assets/haruto.model.json","scale":0.12,"position":[0,0],"mobileScale":0.08,"mobilePosition":[0,0],"mobileStageStyle":{"width":180},"stageStyle":{"width":250}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:false,tips:{style: {"width":230,"height":120,"left":"calc(50% - 20px)","top":"-100px"},mobileStyle: {"width":180,"height":80,"left":"calc(50% - 30px)","top":"-100px"},idleTips:{interval:15000,message:function(){
  return axios.get('https://v1.hitokoto.cn?c=i')
    .then(function (response) {
      return response.data.hitokoto ;
    })
    .catch(function (error) {
      console.error(error);
    });
}
}}});</script><!-- hexo injector body_end end --></body>
</html>
